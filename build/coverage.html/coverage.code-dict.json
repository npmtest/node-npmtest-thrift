{"/home/travis/build/npmtest/node-npmtest-thrift/test.js":"/* istanbul instrument in package npmtest_thrift */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-thrift/lib.npmtest_thrift.js":"/* istanbul instrument in package npmtest_thrift */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_thrift = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_thrift = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-thrift/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-thrift && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_thrift */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_thrift\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_thrift.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_thrift.rollup.js'] =\n            local.assetsDict['/assets.npmtest_thrift.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_thrift.__dirname +\n                    '/lib.npmtest_thrift.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/index.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nexports.Thrift = require('./thrift');\n\nvar connection = require('./connection');\nexports.Connection = connection.Connection;\nexports.createClient = connection.createClient;\nexports.createConnection = connection.createConnection;\nexports.createSSLConnection = connection.createSSLConnection;\nexports.createStdIOClient = connection.createStdIOClient;\nexports.createStdIOConnection = connection.createStdIOConnection;\n\nvar httpConnection = require('./http_connection');\nexports.HttpConnection = httpConnection.HttpConnection;\nexports.createHttpConnection = httpConnection.createHttpConnection;\nexports.createHttpClient = httpConnection.createHttpClient;\n\nvar wsConnection = require('./ws_connection');\nexports.WSConnection = wsConnection.WSConnection;\nexports.createWSConnection = wsConnection.createWSConnection;\nexports.createWSClient = wsConnection.createWSClient;\n\nvar xhrConnection = require('./xhr_connection');\nexports.XHRConnection = xhrConnection.XHRConnection;\nexports.createXHRConnection = xhrConnection.createXHRConnection;\nexports.createXHRClient = xhrConnection.createXHRClient;\n\nvar server = require('./server');\nexports.createServer = server.createServer;\nexports.createMultiplexServer = server.createMultiplexServer;\n\nvar web_server = require('./web_server');\nexports.createWebServer = web_server.createWebServer;\n\nexports.Int64 = require('node-int64');\nexports.Q = require('q');\n\nvar mprocessor = require('./multiplexed_processor');\nvar mprotocol = require('./multiplexed_protocol');\nexports.Multiplexer = mprotocol.Multiplexer;\nexports.MultiplexedProcessor = mprocessor.MultiplexedProcessor;\n\n/*\n * Export transport and protocol so they can be used outside of a\n * cassandra/server context\n */\nexports.TFramedTransport = require('./framed_transport');\nexports.TBufferedTransport = require('./buffered_transport');\nexports.TBinaryProtocol = require('./binary_protocol');\nexports.TJSONProtocol = require('./json_protocol');\nexports.TCompactProtocol = require('./compact_protocol');\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/thrift.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar util = require('util');\n\nvar Type = exports.Type = {\n  STOP: 0,\n  VOID: 1,\n  BOOL: 2,\n  BYTE: 3,\n  I08: 3,\n  DOUBLE: 4,\n  I16: 6,\n  I32: 8,\n  I64: 10,\n  STRING: 11,\n  UTF7: 11,\n  STRUCT: 12,\n  MAP: 13,\n  SET: 14,\n  LIST: 15,\n  UTF8: 16,\n  UTF16: 17\n};\n\nexports.MessageType = {\n  CALL: 1,\n  REPLY: 2,\n  EXCEPTION: 3,\n  ONEWAY: 4\n};\n\nexports.TException = TException;\n\nfunction TException(message) {\n  Error.call(this);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n};\nutil.inherits(TException, Error);\n\nvar TApplicationExceptionType = exports.TApplicationExceptionType = {\n  UNKNOWN: 0,\n  UNKNOWN_METHOD: 1,\n  INVALID_MESSAGE_TYPE: 2,\n  WRONG_METHOD_NAME: 3,\n  BAD_SEQUENCE_ID: 4,\n  MISSING_RESULT: 5,\n  INTERNAL_ERROR: 6,\n  PROTOCOL_ERROR: 7,\n  INVALID_TRANSFORM: 8,\n  INVALID_PROTOCOL: 9,\n  UNSUPPORTED_CLIENT_TYPE: 10\n};\n\nexports.TApplicationException = TApplicationException;\n\nfunction TApplicationException(type, message) {\n  TException.call(this);\n  Error.captureStackTrace(this, this.constructor);\n  this.type = type || TApplicationExceptionType.UNKNOWN;\n  this.name = this.constructor.name;\n  this.message = message;\n};\nutil.inherits(TApplicationException, TException);\n\nTApplicationException.prototype.read = function(input) {\n  var ftype;\n  var ret = input.readStructBegin('TApplicationException');\n\n  while(1){\n      ret = input.readFieldBegin();\n      if(ret.ftype == Type.STOP)\n          break;\n\n      switch(ret.fid){\n          case 1:\n              if( ret.ftype == Type.STRING ){\n                  ret = input.readString();\n                  this.message = ret;\n              } else {\n                  ret = input.skip(ret.ftype);\n              }\n              break;\n          case 2:\n              if( ret.ftype == Type.I32 ){\n                  ret = input.readI32();\n                  this.type = ret;\n              } else {\n                  ret   = input.skip(ret.ftype);\n              }\n              break;\n          default:\n              ret = input.skip(ret.ftype);\n              break;\n      }\n      input.readFieldEnd();\n  }\n  input.readStructEnd();\n};\n\nTApplicationException.prototype.write = function(output){\n  output.writeStructBegin('TApplicationException');\n\n  if (this.message) {\n      output.writeFieldBegin('message', Type.STRING, 1);\n      output.writeString(this.message);\n      output.writeFieldEnd();\n  }\n\n  if (this.code) {\n      output.writeFieldBegin('type', Type.I32, 2);\n      output.writeI32(this.code);\n      output.writeFieldEnd();\n  }\n\n  output.writeFieldStop();\n  output.writeStructEnd();\n};\n\nvar TProtocolExceptionType = exports.TProtocolExceptionType = {\n  UNKNOWN: 0,\n  INVALID_DATA: 1,\n  NEGATIVE_SIZE: 2,\n  SIZE_LIMIT: 3,\n  BAD_VERSION: 4,\n  NOT_IMPLEMENTED: 5,\n  DEPTH_LIMIT: 6\n};\n\n\nexports.TProtocolException = TProtocolException;\n\nfunction TProtocolException(type, message) {\n  Error.call(this);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.type = type;\n  this.message = message;\n};\nutil.inherits(TProtocolException, Error);\n\nexports.objectLength = function(obj) {\n  return Object.keys(obj).length;\n};\n\nexports.inherits = function(constructor, superConstructor) {\n  util.inherits(constructor, superConstructor);\n};\n\nvar copyList, copyMap;\n\ncopyList = function(lst, types) {\n\n  if (!lst) {return lst; }\n\n  var type;\n\n  if (types.shift === undefined) {\n    type = types;\n  }\n  else {\n    type = types[0];\n  }\n  var Type = type;\n\n  var len = lst.length, result = [], i, val;\n  for (i = 0; i < len; i++) {\n    val = lst[i];\n    if (type === null) {\n      result.push(val);\n    }\n    else if (type === copyMap || type === copyList) {\n      result.push(type(val, types.slice(1)));\n    }\n    else {\n      result.push(new Type(val));\n    }\n  }\n  return result;\n};\n\ncopyMap = function(obj, types){\n\n  if (!obj) {return obj; }\n\n  var type;\n\n  if (types.shift === undefined) {\n    type = types;\n  }\n  else {\n    type = types[0];\n  }\n  var Type = type;\n\n  var result = {}, val;\n  for(var prop in obj) {\n    if(obj.hasOwnProperty(prop)) {\n      val = obj[prop];\n      if (type === null) {\n        result[prop] = val;\n      }\n      else if (type === copyMap || type === copyList) {\n        result[prop] = type(val, types.slice(1));\n      }\n      else {\n        result[prop] = new Type(val);\n      }\n    }\n  }\n  return result;\n};\n\nmodule.exports.copyMap = copyMap;\nmodule.exports.copyList = copyList;\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/connection.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar util = require('util');\nvar EventEmitter = require(\"events\").EventEmitter;\nvar net = require('net');\nvar tls = require('tls');\nvar thrift = require('./thrift');\n\nvar TBufferedTransport = require('./buffered_transport');\nvar TBinaryProtocol = require('./binary_protocol');\nvar InputBufferUnderrunError = require('./input_buffer_underrun_error');\n\nvar createClient = require('./create_client');\n\nvar binary = require('./binary');\n\nvar Connection = exports.Connection = function(stream, options) {\n  var self = this;\n  EventEmitter.call(this);\n\n  this.seqId2Service = {};\n  this.connection = stream;\n  this.ssl = (stream.encrypted);\n  this.options = options || {};\n  this.transport = this.options.transport || TBufferedTransport;\n  this.protocol = this.options.protocol || TBinaryProtocol;\n  this.offline_queue = [];\n  this.connected = false;\n  this.initialize_retry_vars();\n\n  this._debug = this.options.debug || false;\n  if (this.options.max_attempts &&\n      !isNaN(this.options.max_attempts) &&\n      this.options.max_attempts > 0) {\n     this.max_attempts = +this.options.max_attempts;\n  }\n  this.retry_max_delay = null;\n  if (this.options.retry_max_delay !== undefined &&\n      !isNaN(this.options.retry_max_delay) &&\n      this.options.retry_max_delay > 0) {\n     this.retry_max_delay = this.options.retry_max_delay;\n  }\n  this.connect_timeout = false;\n  if (this.options.connect_timeout &&\n      !isNaN(this.options.connect_timeout) &&\n      this.options.connect_timeout > 0) {\n     this.connect_timeout = +this.options.connect_timeout;\n  }\n\n  this.connection.addListener(this.ssl ? \"secureConnect\" : \"connect\", function() {\n    self.connected = true;\n\n    this.setTimeout(self.options.timeout || 0);\n    this.setNoDelay();\n    this.frameLeft = 0;\n    this.framePos = 0;\n    this.frame = null;\n    self.initialize_retry_vars();\n\n    self.offline_queue.forEach(function(data) {\n      self.connection.write(data);\n    });\n\n    self.emit(\"connect\");\n  });\n\n  this.connection.addListener(\"error\", function(err) {\n    // Only emit the error if no-one else is listening on the connection\n    // or if someone is listening on us, because Node turns unhandled\n    // 'error' events into exceptions.\n    if (self.connection.listeners('error').length === 1 ||\n        self.listeners('error').length > 0) {\n      self.emit(\"error\", err);\n    }\n  });\n\n  // Add a close listener\n  this.connection.addListener(\"close\", function() {\n    self.connection_gone(); // handle close event. try to reconnect\n  });\n\n  this.connection.addListener(\"timeout\", function() {\n    self.emit(\"timeout\");\n  });\n\n  this.connection.addListener(\"data\", self.transport.receiver(function(transport_with_data) {\n    var message = new self.protocol(transport_with_data);\n    try {\n      while (true) {\n        var header = message.readMessageBegin();\n        var dummy_seqid = header.rseqid * -1;\n        var client = self.client;\n        //The Multiplexed Protocol stores a hash of seqid to service names\n        //  in seqId2Service. If the SeqId is found in the hash we need to\n        //  lookup the appropriate client for this call.\n        //  The connection.client object is a single client object when not\n        //  multiplexing, when using multiplexing it is a service name keyed\n        //  hash of client objects.\n        //NOTE: The 2 way interdependencies between protocols, transports,\n        //  connections and clients in the Node.js implementation are irregular\n        //  and make the implementation difficult to extend and maintain. We\n        //  should bring this stuff inline with typical thrift I/O stack\n        //  operation soon.\n        //  --ra\n        var service_name = self.seqId2Service[header.rseqid];\n        if (service_name) {\n          client = self.client[service_name];\n          delete self.seqId2Service[header.rseqid];\n        }\n        /*jshint -W083 */\n        client._reqs[dummy_seqid] = function(err, success){\n          transport_with_data.commitPosition();\n\n          var callback = client._reqs[header.rseqid];\n          delete client._reqs[header.rseqid];\n          if (callback) {\n            callback(err, success);\n          }\n        };\n        /*jshint +W083 */\n\n        if(client['recv_' + header.fname]) {\n          client['recv_' + header.fname](message, header.mtype, dummy_seqid);\n        } else {\n          delete client._reqs[dummy_seqid];\n          self.emit(\"error\",\n                    new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME,\n                             \"Received a response to an unknown RPC function\"));\n        }\n      }\n    }\n    catch (e) {\n      if (e instanceof InputBufferUnderrunError) {\n        transport_with_data.rollbackPosition();\n      }\n      else {\n        self.emit('error', e);\n      }\n    }\n  }));\n};\nutil.inherits(Connection, EventEmitter);\n\nConnection.prototype.end = function() {\n  this.connection.end();\n};\n\nConnection.prototype.destroy = function() {\n  this.connection.destroy();\n};\n\nConnection.prototype.initialize_retry_vars = function () {\n  this.retry_timer = null;\n  this.retry_totaltime = 0;\n  this.retry_delay = 150;\n  this.retry_backoff = 1.7;\n  this.attempts = 0;\n};\n\nConnection.prototype.write = function(data) {\n  if (!this.connected) {\n    this.offline_queue.push(data);\n    return;\n  }\n  this.connection.write(data);\n};\n\nConnection.prototype.connection_gone = function () {\n  var self = this;\n  this.connected = false;\n\n  // If a retry is already in progress, just let that happen\n  if (this.retry_timer) {\n    return;\n  }\n  // We cannot reconnect a secure socket.\n  if (!this.max_attempts || this.ssl) {\n    self.emit(\"close\");\n    return;\n  }\n\n  if (this.retry_max_delay !== null && this.retry_delay >= this.retry_max_delay) {\n    this.retry_delay = this.retry_max_delay;\n  } else {\n    this.retry_delay = Math.floor(this.retry_delay * this.retry_backoff);\n  }\n\n  if (self._debug) {\n    console.log(\"Retry connection in \" + this.retry_delay + \" ms\");\n  }\n\n  if (this.max_attempts && this.attempts >= this.max_attempts) {\n    this.retry_timer = null;\n    console.error(\"thrift: Couldn't get thrift connection after \" + this.max_attempts + \" attempts.\");\n    self.emit(\"close\");\n    return;\n  }\n\n  this.attempts += 1;\n  this.emit(\"reconnecting\", {\n    delay: self.retry_delay,\n    attempt: self.attempts\n  });\n\n  this.retry_timer = setTimeout(function () {\n    if (self._debug) {\n       console.log(\"Retrying connection...\");\n\t}\n\n    self.retry_totaltime += self.retry_delay;\n\n    if (self.connect_timeout && self.retry_totaltime >= self.connect_timeout) {\n       self.retry_timer = null;\n       console.error(\"thrift: Couldn't get thrift connection after \" + self.retry_totaltime + \"ms.\");\n       self.emit(\"close\");\n       return;\n    }\n\n    self.connection.connect(self.port, self.host);\n    self.retry_timer = null;\n  }, this.retry_delay);\n};\n\nexports.createConnection = function(host, port, options) {\n  var stream = net.createConnection(port, host);\n  var connection = new Connection(stream, options);\n  connection.host = host;\n  connection.port = port;\n\n  return connection;\n};\n\nexports.createSSLConnection = function(host, port, options) {\n  var stream = tls.connect(port, host, options);\n  var connection = new Connection(stream, options);\n  connection.host = host;\n  connection.port = port;\n\n  return connection;\n};\n\n\nexports.createClient = createClient;\n\nvar child_process = require('child_process');\nvar StdIOConnection = exports.StdIOConnection = function(command, options) {\n  var command_parts = command.split(' ');\n  command = command_parts[0];\n  var args = command_parts.splice(1,command_parts.length -1);\n  var child = this.child = child_process.spawn(command,args);\n\n  var self = this;\n  EventEmitter.call(this);\n\n  this._debug = options.debug || false;\n  this.connection = child.stdin;\n  this.options = options || {};\n  this.transport = this.options.transport || TBufferedTransport;\n  this.protocol = this.options.protocol || TBinaryProtocol;\n  this.offline_queue = [];\n\n  if(this._debug === true){\n    this.child.stderr.on('data',function(err){\n      console.log(err.toString(),'CHILD ERROR');\n    });\n\n    this.child.on('exit',function(code,signal){\n      console.log(code+':'+signal,'CHILD EXITED');\n    });\n  }\n\n  this.frameLeft = 0;\n  this.framePos = 0;\n  this.frame = null;\n  this.connected = true;\n\n  self.offline_queue.forEach(function(data) {\n      self.connection.write(data);\n  });\n\n\n  this.connection.addListener(\"error\", function(err) {\n    self.emit(\"error\", err);\n  });\n\n  // Add a close listener\n  this.connection.addListener(\"close\", function() {\n    self.emit(\"close\");\n  });\n\n  child.stdout.addListener(\"data\", self.transport.receiver(function(transport_with_data) {\n    var message = new self.protocol(transport_with_data);\n    try {\n      var header = message.readMessageBegin();\n      var dummy_seqid = header.rseqid * -1;\n      var client = self.client;\n      client._reqs[dummy_seqid] = function(err, success){\n        transport_with_data.commitPosition();\n\n        var callback = client._reqs[header.rseqid];\n        delete client._reqs[header.rseqid];\n        if (callback) {\n          callback(err, success);\n        }\n      };\n      client['recv_' + header.fname](message, header.mtype, dummy_seqid);\n    }\n    catch (e) {\n      if (e instanceof InputBufferUnderrunError) {\n        transport_with_data.rollbackPosition();\n      }\n      else {\n        throw e;\n      }\n    }\n  }));\n};\n\nutil.inherits(StdIOConnection, EventEmitter);\n\nStdIOConnection.prototype.end = function() {\n  this.connection.end();\n};\n\nStdIOConnection.prototype.write = function(data) {\n  if (!this.connected) {\n    this.offline_queue.push(data);\n    return;\n  }\n  this.connection.write(data);\n};\n\nexports.createStdIOConnection = function(command,options){\n  return new StdIOConnection(command,options);\n};\n\nexports.createStdIOClient = createClient;\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/buffered_transport.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar binary = require('./binary');\nvar InputBufferUnderrunError = require('./input_buffer_underrun_error');\n\nmodule.exports = TBufferedTransport;\n\nfunction TBufferedTransport(buffer, callback) {\n  this.defaultReadBufferSize = 1024;\n  this.writeBufferSize = 512; // Soft Limit\n  this.inBuf = new Buffer(this.defaultReadBufferSize);\n  this.readCursor = 0;\n  this.writeCursor = 0; // for input buffer\n  this.outBuffers = [];\n  this.outCount = 0;\n  this.onFlush = callback;\n};\n\nTBufferedTransport.receiver = function(callback, seqid) {\n  var reader = new TBufferedTransport();\n\n  return function(data) {\n    if (reader.writeCursor + data.length > reader.inBuf.length) {\n      var buf = new Buffer(reader.writeCursor + data.length);\n      reader.inBuf.copy(buf, 0, 0, reader.writeCursor);\n      reader.inBuf = buf;\n    }\n    data.copy(reader.inBuf, reader.writeCursor, 0);\n    reader.writeCursor += data.length;\n\n    callback(reader, seqid);\n  };\n};\n\n\nTBufferedTransport.prototype.commitPosition = function(){\n  var unreadSize = this.writeCursor - this.readCursor;\n  var bufSize = (unreadSize * 2 > this.defaultReadBufferSize) ?\n    unreadSize * 2 : this.defaultReadBufferSize;\n  var buf = new Buffer(bufSize);\n  if (unreadSize > 0) {\n    this.inBuf.copy(buf, 0, this.readCursor, this.writeCursor);\n  }\n  this.readCursor = 0;\n  this.writeCursor = unreadSize;\n  this.inBuf = buf;\n};\n\nTBufferedTransport.prototype.rollbackPosition = function(){\n  this.readCursor = 0;\n}\n\n  // TODO: Implement open/close support\nTBufferedTransport.prototype.isOpen = function() {\n  return true;\n};\n\nTBufferedTransport.prototype.open = function() {\n};\n\nTBufferedTransport.prototype.close = function() {\n};\n\n  // Set the seqid of the message in the client\n  // So that callbacks can be found\nTBufferedTransport.prototype.setCurrSeqId = function(seqid) {\n  this._seqid = seqid;\n};\n\nTBufferedTransport.prototype.ensureAvailable = function(len) {\n  if (this.readCursor + len > this.writeCursor) {\n    throw new InputBufferUnderrunError();\n  }\n};\n\nTBufferedTransport.prototype.read = function(len) {\n  this.ensureAvailable(len);\n  var buf = new Buffer(len);\n  this.inBuf.copy(buf, 0, this.readCursor, this.readCursor + len);\n  this.readCursor += len;\n  return buf;\n};\n\nTBufferedTransport.prototype.readByte = function() {\n  this.ensureAvailable(1);\n  return binary.readByte(this.inBuf[this.readCursor++]);\n};\n\nTBufferedTransport.prototype.readI16 = function() {\n  this.ensureAvailable(2);\n  var i16 = binary.readI16(this.inBuf, this.readCursor);\n  this.readCursor += 2;\n  return i16;\n};\n\nTBufferedTransport.prototype.readI32 = function() {\n  this.ensureAvailable(4);\n  var i32 = binary.readI32(this.inBuf, this.readCursor);\n  this.readCursor += 4;\n  return i32;\n};\n\nTBufferedTransport.prototype.readDouble = function() {\n  this.ensureAvailable(8);\n  var d = binary.readDouble(this.inBuf, this.readCursor);\n  this.readCursor += 8;\n  return d;\n};\n\nTBufferedTransport.prototype.readString = function(len) {\n  this.ensureAvailable(len);\n  var str = this.inBuf.toString('utf8', this.readCursor, this.readCursor + len);\n  this.readCursor += len;\n  return str;\n};\n\nTBufferedTransport.prototype.borrow = function() {\n  var obj = {buf: this.inBuf, readIndex: this.readCursor, writeIndex: this.writeCursor};\n  return obj;\n};\n\nTBufferedTransport.prototype.consume = function(bytesConsumed) {\n  this.readCursor += bytesConsumed;\n};\n\nTBufferedTransport.prototype.write = function(buf) {\n  if (typeof(buf) === \"string\") {\n    buf = new Buffer(buf, 'utf8');\n  }\n  this.outBuffers.push(buf);\n  this.outCount += buf.length;\n};\n\nTBufferedTransport.prototype.flush = function() {\n  // If the seqid of the callback is available pass it to the onFlush\n  // Then remove the current seqid\n  var seqid = this._seqid;\n  this._seqid = null;\n\n  if (this.outCount < 1) {\n    return;\n  }\n\n  var msg = new Buffer(this.outCount),\n      pos = 0;\n  this.outBuffers.forEach(function(buf) {\n    buf.copy(msg, pos, 0);\n    pos += buf.length;\n  });\n\n  if (this.onFlush) {\n    // Passing seqid through this call to get it to the connection\n    this.onFlush(msg, seqid);\n  }\n\n  this.outBuffers = [];\n  this.outCount = 0;\n}\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/binary.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar POW_8 = Math.pow(2, 8);\nvar POW_16 = Math.pow(2, 16);\nvar POW_24 = Math.pow(2, 24);\nvar POW_32 = Math.pow(2, 32);\nvar POW_40 = Math.pow(2, 40);\nvar POW_48 = Math.pow(2, 48);\nvar POW_52 = Math.pow(2, 52);\nvar POW_1022 = Math.pow(2, 1022);\n\nexports.readByte = function(b){\n\treturn b > 127 ? b-256 : b;\n};\n\nexports.readI16 = function(buff, off) {\n  off = off || 0;\n  var v = buff[off + 1];\n  v += buff[off] << 8;\n  if (buff[off] & 128) {\n    v -= POW_16;\n  }\n  return v;\n};\n\nexports.readI32 = function(buff, off) {\n  off = off || 0;\n  var v = buff[off + 3];\n  v += buff[off + 2] << 8;\n  v += buff[off + 1] << 16;\n  v += buff[off] * POW_24;\n  if (buff[off] & 0x80) {\n    v -= POW_32;\n  }\n  return v;\n};\n\nexports.writeI16 = function(buff, v) {\n  buff[1] = v & 0xff;\n  v >>= 8;\n  buff[0] = v & 0xff;\n  return buff;\n};\n\nexports.writeI32 = function(buff, v) {\n  buff[3] = v & 0xff;\n  v >>= 8;\n  buff[2] = v & 0xff;\n  v >>= 8;\n  buff[1] = v & 0xff;\n  v >>= 8;\n  buff[0] = v & 0xff;\n  return buff;\n};\n\nexports.readDouble = function(buff, off) {\n  off = off || 0;\n  var signed = buff[off] & 0x80;\n  var e = (buff[off+1] & 0xF0) >> 4;\n  e += (buff[off] & 0x7F) << 4;\n\n  var m = buff[off+7];\n  m += buff[off+6] << 8;\n  m += buff[off+5] << 16;\n  m += buff[off+4] * POW_24;\n  m += buff[off+3] * POW_32;\n  m += buff[off+2] * POW_40;\n  m += (buff[off+1] & 0x0F) * POW_48;\n\n  switch (e) {\n    case 0:\n      e = -1022;\n      break;\n    case 2047:\n      return m ? NaN : (signed ? -Infinity : Infinity);\n    default:\n      m += POW_52;\n      e -= 1023;\n  }\n\n  if (signed) {\n    m *= -1;\n  }\n\n  return m * Math.pow(2, e - 52);\n};\n\n/*\n * Based on code from the jspack module:\n * http://code.google.com/p/jspack/\n */\nexports.writeDouble = function(buff, v) {\n  var m, e, c;\n\n  buff[0] = (v < 0 ? 0x80 : 0x00);\n\n  v = Math.abs(v);\n  if (v !== v) {\n    // NaN, use QNaN IEEE format\n    m = 2251799813685248;\n    e = 2047;\n  } else if (v === Infinity) {\n    m = 0;\n    e = 2047;\n  } else {\n    e = Math.floor(Math.log(v) / Math.LN2);\n    c = Math.pow(2, -e);\n    if (v * c < 1) {\n      e--;\n      c *= 2;\n    }\n\n    if (e + 1023 >= 2047)\n    {\n      // Overflow\n      m = 0;\n      e = 2047;\n    }\n    else if (e + 1023 >= 1)\n    {\n      // Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow\n      m = (v*c-1) * POW_52;\n      e += 1023;\n    }\n    else\n    {\n      // Denormalized - also catches the '0' case, somewhat by chance\n      m = (v * POW_1022) * POW_52;\n      e = 0;\n    }\n  }\n\n  buff[1] = (e << 4) & 0xf0;\n  buff[0] |= (e >> 4) & 0x7f;\n\n  buff[7] = m & 0xff;\n  m = Math.floor(m / POW_8);\n  buff[6] = m & 0xff;\n  m = Math.floor(m / POW_8);\n  buff[5] = m & 0xff;\n  m = Math.floor(m / POW_8);\n  buff[4] = m & 0xff;\n  m >>= 8;\n  buff[3] = m & 0xff;\n  m >>= 8;\n  buff[2] = m & 0xff;\n  m >>= 8;\n  buff[1] |= m & 0x0f;\n\n  return buff;\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/input_buffer_underrun_error.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar util = require(\"util\");\n\nmodule.exports = InputBufferUnderrunError;\n\nfunction InputBufferUnderrunError(message) {\n  Error.call(this);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n};\n\nutil.inherits(InputBufferUnderrunError, Error);\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/binary_protocol.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar log = require('./log');\nvar binary = require('./binary');\nvar Int64 = require('node-int64');\nvar Thrift = require('./thrift');\nvar Type = Thrift.Type;\n\nmodule.exports = TBinaryProtocol;\n\n// JavaScript supports only numeric doubles, therefore even hex values are always signed.\n// The largest integer value which can be represented in JavaScript is +/-2^53.\n// Bitwise operations convert numbers to 32 bit integers but perform sign extension\n// upon assigning values back to variables.\nvar VERSION_MASK = -65536,   // 0xffff0000\n    VERSION_1 = -2147418112, // 0x80010000\n    TYPE_MASK = 0x000000ff;\n\nfunction TBinaryProtocol(trans, strictRead, strictWrite) {\n  this.trans = trans;\n  this.strictRead = (strictRead !== undefined ? strictRead : false);\n  this.strictWrite = (strictWrite !== undefined ? strictWrite : true);\n};\n\nTBinaryProtocol.prototype.flush = function() {\n  return this.trans.flush();\n};\n\nTBinaryProtocol.prototype.writeMessageBegin = function(name, type, seqid) {\n    if (this.strictWrite) {\n      this.writeI32(VERSION_1 | type);\n      this.writeString(name);\n      this.writeI32(seqid);\n    } else {\n      this.writeString(name);\n      this.writeByte(type);\n      this.writeI32(seqid);\n    }\n    // Record client seqid to find callback again\n    if (this._seqid) {\n      // TODO better logging log warning\n      log.warning('SeqId already set', { 'name': name });\n    } else {\n      this._seqid = seqid;\n      this.trans.setCurrSeqId(seqid);\n    }\n};\n\nTBinaryProtocol.prototype.writeMessageEnd = function() {\n    if (this._seqid) {\n        this._seqid = null;\n    } else {\n        log.warning('No seqid to unset');\n    }\n};\n\nTBinaryProtocol.prototype.writeStructBegin = function(name) {\n};\n\nTBinaryProtocol.prototype.writeStructEnd = function() {\n};\n\nTBinaryProtocol.prototype.writeFieldBegin = function(name, type, id) {\n  this.writeByte(type);\n  this.writeI16(id);\n};\n\nTBinaryProtocol.prototype.writeFieldEnd = function() {\n};\n\nTBinaryProtocol.prototype.writeFieldStop = function() {\n  this.writeByte(Type.STOP);\n};\n\nTBinaryProtocol.prototype.writeMapBegin = function(ktype, vtype, size) {\n  this.writeByte(ktype);\n  this.writeByte(vtype);\n  this.writeI32(size);\n};\n\nTBinaryProtocol.prototype.writeMapEnd = function() {\n};\n\nTBinaryProtocol.prototype.writeListBegin = function(etype, size) {\n  this.writeByte(etype);\n  this.writeI32(size);\n};\n\nTBinaryProtocol.prototype.writeListEnd = function() {\n};\n\nTBinaryProtocol.prototype.writeSetBegin = function(etype, size) {\n  this.writeByte(etype);\n  this.writeI32(size);\n};\n\nTBinaryProtocol.prototype.writeSetEnd = function() {\n};\n\nTBinaryProtocol.prototype.writeBool = function(bool) {\n  if (bool) {\n    this.writeByte(1);\n  } else {\n    this.writeByte(0);\n  }\n};\n\nTBinaryProtocol.prototype.writeByte = function(b) {\n  this.trans.write(new Buffer([b]));\n};\n\nTBinaryProtocol.prototype.writeI16 = function(i16) {\n  this.trans.write(binary.writeI16(new Buffer(2), i16));\n};\n\nTBinaryProtocol.prototype.writeI32 = function(i32) {\n  this.trans.write(binary.writeI32(new Buffer(4), i32));\n};\n\nTBinaryProtocol.prototype.writeI64 = function(i64) {\n  if (i64.buffer) {\n    this.trans.write(i64.buffer);\n  } else {\n    this.trans.write(new Int64(i64).buffer);\n  }\n};\n\nTBinaryProtocol.prototype.writeDouble = function(dub) {\n  this.trans.write(binary.writeDouble(new Buffer(8), dub));\n};\n\nTBinaryProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {\n  if (typeof(arg) === 'string') {\n    this.writeI32(Buffer.byteLength(arg, encoding));\n    this.trans.write(new Buffer(arg, encoding));\n  } else if ((arg instanceof Buffer) ||\n             (Object.prototype.toString.call(arg) == '[object Uint8Array]')) {\n    // Buffers in Node.js under Browserify may extend UInt8Array instead of\n    // defining a new object. We detect them here so we can write them\n    // correctly\n    this.writeI32(arg.length);\n    this.trans.write(arg);\n  } else {\n    throw new Error(name + ' called without a string/Buffer argument: ' + arg);\n  }\n};\n\nTBinaryProtocol.prototype.writeString = function(arg) {\n  this.writeStringOrBinary('writeString', 'utf8', arg);\n};\n\nTBinaryProtocol.prototype.writeBinary = function(arg) {\n  this.writeStringOrBinary('writeBinary', 'binary', arg);\n};\n\nTBinaryProtocol.prototype.readMessageBegin = function() {\n  var sz = this.readI32();\n  var type, name, seqid;\n\n  if (sz < 0) {\n    var version = sz & VERSION_MASK;\n    if (version != VERSION_1) {\n      console.log(\"BAD: \" + version);\n      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, \"Bad version in readMessageBegin: \" + sz);\n    }\n    type = sz & TYPE_MASK;\n    name = this.readString();\n    seqid = this.readI32();\n  } else {\n    if (this.strictRead) {\n      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, \"No protocol version header\");\n    }\n    name = this.trans.read(sz);\n    type = this.readByte();\n    seqid = this.readI32();\n  }\n  return {fname: name, mtype: type, rseqid: seqid};\n};\n\nTBinaryProtocol.prototype.readMessageEnd = function() {\n};\n\nTBinaryProtocol.prototype.readStructBegin = function() {\n  return {fname: ''};\n};\n\nTBinaryProtocol.prototype.readStructEnd = function() {\n};\n\nTBinaryProtocol.prototype.readFieldBegin = function() {\n  var type = this.readByte();\n  if (type == Type.STOP) {\n    return {fname: null, ftype: type, fid: 0};\n  }\n  var id = this.readI16();\n  return {fname: null, ftype: type, fid: id};\n};\n\nTBinaryProtocol.prototype.readFieldEnd = function() {\n};\n\nTBinaryProtocol.prototype.readMapBegin = function() {\n  var ktype = this.readByte();\n  var vtype = this.readByte();\n  var size = this.readI32();\n  return {ktype: ktype, vtype: vtype, size: size};\n};\n\nTBinaryProtocol.prototype.readMapEnd = function() {\n};\n\nTBinaryProtocol.prototype.readListBegin = function() {\n  var etype = this.readByte();\n  var size = this.readI32();\n  return {etype: etype, size: size};\n};\n\nTBinaryProtocol.prototype.readListEnd = function() {\n};\n\nTBinaryProtocol.prototype.readSetBegin = function() {\n  var etype = this.readByte();\n  var size = this.readI32();\n  return {etype: etype, size: size};\n};\n\nTBinaryProtocol.prototype.readSetEnd = function() {\n};\n\nTBinaryProtocol.prototype.readBool = function() {\n  var b = this.readByte();\n  if (b === 0) {\n    return false;\n  }\n  return true;\n};\n\nTBinaryProtocol.prototype.readByte = function() {\n  return this.trans.readByte();\n};\n\nTBinaryProtocol.prototype.readI16 = function() {\n  return this.trans.readI16();\n};\n\nTBinaryProtocol.prototype.readI32 = function() {\n  return this.trans.readI32();\n};\n\nTBinaryProtocol.prototype.readI64 = function() {\n  var buff = this.trans.read(8);\n  return new Int64(buff);\n};\n\nTBinaryProtocol.prototype.readDouble = function() {\n  return this.trans.readDouble();\n};\n\nTBinaryProtocol.prototype.readBinary = function() {\n  var len = this.readI32();\n  if (len === 0) {\n    return new Buffer(0);\n  }\n\n  if (len < 0) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, \"Negative binary size\");\n  }\n  return this.trans.read(len);\n};\n\nTBinaryProtocol.prototype.readString = function() {\n  var len = this.readI32();\n  if (len === 0) {\n    return \"\";\n  }\n\n  if (len < 0) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, \"Negative string size\");\n  }\n  return this.trans.readString(len);\n};\n\nTBinaryProtocol.prototype.getTransport = function() {\n  return this.trans;\n};\n\nTBinaryProtocol.prototype.skip = function(type) {\n  switch (type) {\n    case Type.STOP:\n      return;\n    case Type.BOOL:\n      this.readBool();\n      break;\n    case Type.BYTE:\n      this.readByte();\n      break;\n    case Type.I16:\n      this.readI16();\n      break;\n    case Type.I32:\n      this.readI32();\n      break;\n    case Type.I64:\n      this.readI64();\n      break;\n    case Type.DOUBLE:\n      this.readDouble();\n      break;\n    case Type.STRING:\n      this.readString();\n      break;\n    case Type.STRUCT:\n      this.readStructBegin();\n      while (true) {\n        var r = this.readFieldBegin();\n        if (r.ftype === Type.STOP) {\n          break;\n        }\n        this.skip(r.ftype);\n        this.readFieldEnd();\n      }\n      this.readStructEnd();\n      break;\n    case Type.MAP:\n      var mapBegin = this.readMapBegin();\n      for (var i = 0; i < mapBegin.size; ++i) {\n        this.skip(mapBegin.ktype);\n        this.skip(mapBegin.vtype);\n      }\n      this.readMapEnd();\n      break;\n    case Type.SET:\n      var setBegin = this.readSetBegin();\n      for (var i2 = 0; i2 < setBegin.size; ++i2) {\n        this.skip(setBegin.etype);\n      }\n      this.readSetEnd();\n      break;\n    case Type.LIST:\n      var listBegin = this.readListBegin();\n      for (var i3 = 0; i3 < listBegin.size; ++i3) {\n        this.skip(listBegin.etype);\n      }\n      this.readListEnd();\n      break;\n    default:\n      throw new  Error(\"Invalid type: \" + type);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/log.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nmodule.exports = {\n  'info' : function logInfo() {},\n  'warning' : function logWarning() {},\n  'error' : function logError() {},\n  'debug' : function logDebug() {},\n  'trace' : function logTrace() {}\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/create_client.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nmodule.exports = createClient;\n\n/**\n * Creates a new client object for the specified Thrift service.\n * @param {object} ServiceClient - The module containing the generated service client\n * @param {Connection} Connection - The connection to use.\n * @returns {object} The client object.\n */\nfunction createClient(ServiceClient, connection) {\n  // TODO validate required options and throw otherwise\n  if (ServiceClient.Client) {\n    ServiceClient = ServiceClient.Client;\n  }\n  // TODO detangle these initialization calls\n  // creating \"client\" requires\n  //   - new service client instance\n  //\n  // New service client instance requires\n  //   - new transport instance\n  //   - protocol class reference\n  //\n  // New transport instance requires\n  //   - Buffer to use (or none)\n  //   - Callback to call on flush\n\n  // Wrap the write method\n  var writeCb = function(buf, seqid) {\n    connection.write(buf, seqid);\n  };\n  var transport = new connection.transport(undefined, writeCb);\n  var client = new ServiceClient(transport, connection.protocol);\n  transport.client = client;\n  connection.client = client;\n  return client;\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/http_connection.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar util = require('util');\nvar http = require('http');\nvar https = require('https');\nvar EventEmitter = require('events').EventEmitter;\nvar thrift = require('./thrift');\n\nvar TBufferedTransport = require('./buffered_transport');\nvar TBinaryProtocol = require('./binary_protocol');\nvar InputBufferUnderrunError = require('./input_buffer_underrun_error');\n\nvar createClient = require('./create_client');\n\n/**\n * @class\n * @name ConnectOptions\n * @property {string} transport - The Thrift layered transport to use (TBufferedTransport, etc).\n * @property {string} protocol - The Thrift serialization protocol to use (TBinaryProtocol, etc.).\n * @property {string} path - The URL path to POST to (e.g. \"/\", \"/mySvc\", \"/thrift/quoteSvc\", etc.).\n * @property {object} headers - A standard Node.js header hash, an object hash containing key/value\n *        pairs where the key is the header name string and the value is the header value string.\n * @property {boolean} https - True causes the connection to use https, otherwise http is used.\n * @property {object} nodeOptions - Options passed on to node.\n * @example\n *     //Use a connection that requires ssl/tls, closes the connection after each request,\n *     //  uses the buffered transport layer, uses the JSON protocol and directs RPC traffic\n *     //  to https://thrift.example.com:9090/hello\n *     var thrift = require('thrift');\n *     var options = {\n *        transport: thrift.TBufferedTransport,\n *        protocol: thrift.TJSONProtocol,\n *        path: \"/hello\",\n *        headers: {\"Connection\": \"close\"},\n *        https: true\n *     };\n *     var con = thrift.createHttpConnection(\"thrift.example.com\", 9090, options);\n *     var client = thrift.createHttpClient(myService, connection);\n *     client.myServiceFunction();\n */\n\n/**\n * Initializes a Thrift HttpConnection instance (use createHttpConnection() rather than\n *    instantiating directly).\n * @constructor\n * @param {string} host - The host name or IP to connect to.\n * @param {number} port - The TCP port to connect to.\n * @param {ConnectOptions} options - The configuration options to use.\n * @throws {error} Exceptions other than InputBufferUnderrunError are rethrown\n * @event {error} The \"error\" event is fired when a Node.js error event occurs during\n *     request or response processing, in which case the node error is passed on. An \"error\"\n *     event may also be fired when the connection can not map a response back to the\n *     appropriate client (an internal error), generating a TApplicationException.\n * @classdesc HttpConnection objects provide Thrift end point transport\n *     semantics implemented over the Node.js http.request() method.\n * @see {@link createHttpConnection}\n */\nvar HttpConnection = exports.HttpConnection = function(host, port, options) {\n  //Initialize the emitter base object\n  EventEmitter.call(this);\n\n  //Set configuration\n  var self = this;\n  this.options = options || {};\n  this.host = host;\n  this.port = port;\n  this.https = this.options.https || false;\n  this.transport = this.options.transport || TBufferedTransport;\n  this.protocol = this.options.protocol || TBinaryProtocol;\n\n  //Prepare Node.js options\n  this.nodeOptions = {\n    host: this.host,\n    port: this.port || 80,\n    path: this.options.path || '/',\n    method: 'POST',\n    headers: this.options.headers || {},\n    responseType: this.options.responseType || null\n  };\n  for (var attrname in this.options.nodeOptions) {\n    this.nodeOptions[attrname] = this.options.nodeOptions[attrname];\n  }\n  /*jshint -W069 */\n  if (! this.nodeOptions.headers['Connection']) {\n    this.nodeOptions.headers['Connection'] = 'keep-alive';\n  }\n  /*jshint +W069 */\n\n  //The sequence map is used to map seqIDs back to the\n  //  calling client in multiplexed scenarios\n  this.seqId2Service = {};\n\n  function decodeCallback(transport_with_data) {\n    var proto = new self.protocol(transport_with_data);\n    try {\n      while (true) {\n        var header = proto.readMessageBegin();\n        var dummy_seqid = header.rseqid * -1;\n        var client = self.client;\n        //The Multiplexed Protocol stores a hash of seqid to service names\n        //  in seqId2Service. If the SeqId is found in the hash we need to\n        //  lookup the appropriate client for this call.\n        //  The client var is a single client object when not multiplexing,\n        //  when using multiplexing it is a service name keyed hash of client\n        //  objects.\n        //NOTE: The 2 way interdependencies between protocols, transports,\n        //  connections and clients in the Node.js implementation are irregular\n        //  and make the implementation difficult to extend and maintain. We\n        //  should bring this stuff inline with typical thrift I/O stack\n        //  operation soon.\n        //  --ra\n        var service_name = self.seqId2Service[header.rseqid];\n        if (service_name) {\n          client = self.client[service_name];\n          delete self.seqId2Service[header.rseqid];\n        }\n        /*jshint -W083 */\n        client._reqs[dummy_seqid] = function(err, success){\n          transport_with_data.commitPosition();\n          var clientCallback = client._reqs[header.rseqid];\n          delete client._reqs[header.rseqid];\n          if (clientCallback) {\n            process.nextTick(function() {\n              clientCallback(err, success);\n            });\n          }\n        };\n        /*jshint +W083 */\n        if(client['recv_' + header.fname]) {\n          client['recv_' + header.fname](proto, header.mtype, dummy_seqid);\n        } else {\n          delete client._reqs[dummy_seqid];\n          self.emit(\"error\",\n                    new thrift.TApplicationException(\n                       thrift.TApplicationExceptionType.WRONG_METHOD_NAME,\n                       \"Received a response to an unknown RPC function\"));\n        }\n      }\n    }\n    catch (e) {\n      if (e instanceof InputBufferUnderrunError) {\n        transport_with_data.rollbackPosition();\n      } else {\n        self.emit('error', e);\n      }\n    }\n  }\n\n\n  //Response handler\n  //////////////////////////////////////////////////\n  this.responseCallback = function(response) {\n    var data = [];\n    var dataLen = 0;\n\n    response.on('error', function (e) {\n      self.emit(\"error\", e);\n    });\n\n    // When running directly under node, chunk will be a buffer,\n    // however, when running in a Browser (e.g. Browserify), chunk\n    // will be a string or an ArrayBuffer.\n    response.on('data', function (chunk) {\n      if ((typeof chunk == 'string') ||\n          (Object.prototype.toString.call(chunk) == '[object Uint8Array]')) {\n        // Wrap ArrayBuffer/string in a Buffer so data[i].copy will work\n        data.push(new Buffer(chunk));\n      } else {\n        data.push(chunk);\n      }\n      dataLen += chunk.length;\n    });\n\n    response.on('end', function(){\n      var buf = new Buffer(dataLen);\n      for (var i=0, len=data.length, pos=0; i<len; i++) {\n        data[i].copy(buf, pos);\n        pos += data[i].length;\n      }\n      //Get the receiver function for the transport and\n      //  call it with the buffer\n      self.transport.receiver(decodeCallback)(buf);\n    });\n  };\n};\nutil.inherits(HttpConnection, EventEmitter);\n\n/**\n * Writes Thrift message data to the connection\n * @param {Buffer} data - A Node.js Buffer containing the data to write\n * @returns {void} No return value.\n * @event {error} the \"error\" event is raised upon request failure passing the\n *     Node.js error object to the listener.\n */\nHttpConnection.prototype.write = function(data) {\n  var self = this;\n  self.nodeOptions.headers[\"Content-length\"] = data.length;\n  var req = (self.https) ?\n      https.request(self.nodeOptions, self.responseCallback) :\n      http.request(self.nodeOptions, self.responseCallback);\n  req.on('error', function(err) {\n    self.emit(\"error\", err);\n  });\n  req.write(data);\n  req.end();\n};\n\n/**\n * Creates a new HttpConnection object, used by Thrift clients to connect\n *    to Thrift HTTP based servers.\n * @param {string} host - The host name or IP to connect to.\n * @param {number} port - The TCP port to connect to.\n * @param {ConnectOptions} options - The configuration options to use.\n * @returns {HttpConnection} The connection object.\n * @see {@link ConnectOptions}\n */\nexports.createHttpConnection = function(host, port, options) {\n  return new HttpConnection(host, port, options);\n};\n\nexports.createHttpClient = createClient\n\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/ws_connection.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar util = require('util');\nvar WebSocket = require('ws');\nvar EventEmitter = require(\"events\").EventEmitter;\nvar thrift = require('./thrift');\nvar ttransport = require('./transport');\nvar tprotocol = require('./protocol');\n\nvar TBufferedTransport = require('./buffered_transport');\nvar TJSONProtocol = require('./json_protocol');\nvar InputBufferUnderrunError = require('./input_buffer_underrun_error');\n\nvar createClient = require('./create_client');\n\nexports.WSConnection = WSConnection;\n\n/**\n * @class\n * @name WSConnectOptions\n * @property {string} transport - The Thrift layered transport to use (TBufferedTransport, etc).\n * @property {string} protocol - The Thrift serialization protocol to use (TJSONProtocol, etc.).\n * @property {string} path - The URL path to connect to (e.g. \"/\", \"/mySvc\", \"/thrift/quoteSvc\", etc.).\n * @property {object} headers - A standard Node.js header hash, an object hash containing key/value\n *        pairs where the key is the header name string and the value is the header value string.\n * @property {boolean} secure - True causes the connection to use wss, otherwise ws is used.\n * @property {object} wsOptions - Options passed on to WebSocket.\n * @example\n *     //Use a secured websocket connection\n *     //  uses the buffered transport layer, uses the JSON protocol and directs RPC traffic\n *     //  to wss://thrift.example.com:9090/hello\n *     var thrift = require('thrift');\n *     var options = {\n *        transport: thrift.TBufferedTransport,\n *        protocol: thrift.TJSONProtocol,\n *        path: \"/hello\",\n *        secure: true\n *     };\n *     var con = thrift.createWSConnection(\"thrift.example.com\", 9090, options);\n *     con.open()\n *     var client = thrift.createWSClient(myService, connection);\n *     client.myServiceFunction();\n *     con.close()\n */\n\n/**\n * Initializes a Thrift WSConnection instance (use createWSConnection() rather than\n *    instantiating directly).\n * @constructor\n * @param {string} host - The host name or IP to connect to.\n * @param {number} port - The TCP port to connect to.\n * @param {WSConnectOptions} options - The configuration options to use.\n * @throws {error} Exceptions other than ttransport.InputBufferUnderrunError are rethrown\n * @event {error} The \"error\" event is fired when a Node.js error event occurs during\n *     request or response processing, in which case the node error is passed on. An \"error\"\n *     event may also be fired when the connectison can not map a response back to the\n *     appropriate client (an internal error), generating a TApplicationException.\n * @classdesc WSConnection objects provide Thrift end point transport\n *     semantics implemented using Websockets.\n * @see {@link createWSConnection}\n */\nfunction WSConnection(host, port, options) {\n  //Initialize the emitter base object\n  EventEmitter.call(this);\n\n  //Set configuration\n  var self = this;\n  this.options = options || {};\n  this.host = host;\n  this.port = port;\n  this.secure = this.options.secure || false;\n  this.transport = this.options.transport || TBufferedTransport;\n  this.protocol = this.options.protocol || TJSONProtocol;\n  this.path = this.options.path;\n  this.send_pending = [];\n\n  //The sequence map is used to map seqIDs back to the\n  //  calling client in multiplexed scenarios\n  this.seqId2Service = {};\n\n  //Prepare WebSocket options\n  this.wsOptions = {\n    host: this.host,\n    port: this.port || 80,\n    path: this.options.path || '/',\n    headers: this.options.headers || {}\n  };\n  for (var attrname in this.options.wsOptions) {\n    this.wsOptions[attrname] = this.options.wsOptions[attrname];\n  }\n};\nutil.inherits(WSConnection, EventEmitter);\n\nWSConnection.prototype.__reset = function() {\n  this.socket = null; //The web socket\n  this.send_pending = []; //Buffers/Callback pairs waiting to be sent\n};\n\nWSConnection.prototype.__onOpen = function() {\n  var self = this;\n  this.emit(\"open\");\n  if (this.send_pending.length > 0) {\n    //If the user made calls before the connection was fully\n    //open, send them now\n    this.send_pending.forEach(function(data) {\n      self.socket.send(data);\n    });\n    this.send_pending = [];\n  }\n};\n\nWSConnection.prototype.__onClose = function(evt) {\n  this.emit(\"close\");\n  this.__reset();\n};\n\nWSConnection.prototype.__decodeCallback = function(transport_with_data) {\n  var proto = new this.protocol(transport_with_data);\n  try {\n    while (true) {\n      var header = proto.readMessageBegin();\n      var dummy_seqid = header.rseqid * -1;\n      var client = this.client;\n      //The Multiplexed Protocol stores a hash of seqid to service names\n      //  in seqId2Service. If the SeqId is found in the hash we need to\n      //  lookup the appropriate client for this call.\n      //  The client var is a single client object when not multiplexing,\n      //  when using multiplexing it is a service name keyed hash of client\n      //  objects.\n      //NOTE: The 2 way interdependencies between protocols, transports,\n      //  connections and clients in the Node.js implementation are irregular\n      //  and make the implementation difficult to extend and maintain. We\n      //  should bring this stuff inline with typical thrift I/O stack\n      //  operation soon.\n      //  --ra\n      var service_name = this.seqId2Service[header.rseqid];\n      if (service_name) {\n        client = this.client[service_name];\n        delete this.seqId2Service[header.rseqid];\n      }\n      /*jshint -W083 */\n      client._reqs[dummy_seqid] = function(err, success) {\n        transport_with_data.commitPosition();\n        var clientCallback = client._reqs[header.rseqid];\n        delete client._reqs[header.rseqid];\n        if (clientCallback) {\n          clientCallback(err, success);\n        }\n      };\n      /*jshint +W083 */\n      if (client['recv_' + header.fname]) {\n        client['recv_' + header.fname](proto, header.mtype, dummy_seqid);\n      } else {\n        delete client._reqs[dummy_seqid];\n        this.emit(\"error\",\n          new thrift.TApplicationException(\n            thrift.TApplicationExceptionType.WRONG_METHOD_NAME,\n            \"Received a response to an unknown RPC function\"));\n      }\n    }\n  } catch (e) {\n    if (e instanceof InputBufferUnderrunError) {\n      transport_with_data.rollbackPosition();\n    } else {\n      throw e;\n    }\n  }\n};\n\nWSConnection.prototype.__onData = function(data) {\n  if (Object.prototype.toString.call(data) == \"[object ArrayBuffer]\") {\n    data = new Uint8Array(data);\n  }\n  var buf = new Buffer(data);\n  this.transport.receiver(this.__decodeCallback.bind(this))(buf);\n\n};\n\nWSConnection.prototype.__onMessage = function(evt) {\n  this.__onData(evt.data);\n};\n\nWSConnection.prototype.__onError = function(evt) {\n  this.emit(\"error\", evt);\n  this.socket.close();\n};\n\n/**\n * Returns true if the transport is open\n * @readonly\n * @returns {boolean}\n */\nWSConnection.prototype.isOpen = function() {\n  return this.socket && this.socket.readyState == this.socket.OPEN;\n};\n\n/**\n * Opens the transport connection\n */\nWSConnection.prototype.open = function() {\n  //If OPEN/CONNECTING/CLOSING ignore additional opens\n  if (this.socket && this.socket.readyState != this.socket.CLOSED) {\n    return;\n  }\n  //If there is no socket or the socket is closed:\n  this.socket = new WebSocket(this.uri(), \"\", this.wsOptions);\n  this.socket.binaryType = 'arraybuffer';\n  this.socket.onopen = this.__onOpen.bind(this);\n  this.socket.onmessage = this.__onMessage.bind(this);\n  this.socket.onerror = this.__onError.bind(this);\n  this.socket.onclose = this.__onClose.bind(this);\n};\n\n/**\n * Closes the transport connection\n */\nWSConnection.prototype.close = function() {\n  this.socket.close();\n};\n\n/**\n * Return URI for the connection\n * @returns {string} URI\n */\nWSConnection.prototype.uri = function() {\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n  var path = this.path || '/';\n  var host = this.host;\n\n  // avoid port if default for schema\n  if (this.port && (('wss' == schema && this.port != 443) ||\n    ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  return schema + '://' + host + port + path;\n};\n\n/**\n * Writes Thrift message data to the connection\n * @param {Buffer} data - A Node.js Buffer containing the data to write\n * @returns {void} No return value.\n * @event {error} the \"error\" event is raised upon request failure passing the\n *     Node.js error object to the listener.\n */\nWSConnection.prototype.write = function(data) {\n  if (this.isOpen()) {\n    //Send data and register a callback to invoke the client callback\n    this.socket.send(data);\n  } else {\n    //Queue the send to go out __onOpen\n    this.send_pending.push(data);\n  }\n};\n\n/**\n * Creates a new WSConnection object, used by Thrift clients to connect\n *    to Thrift HTTP based servers.\n * @param {string} host - The host name or IP to connect to.\n * @param {number} port - The TCP port to connect to.\n * @param {WSConnectOptions} options - The configuration options to use.\n * @returns {WSConnection} The connection object.\n * @see {@link WSConnectOptions}\n */\nexports.createWSConnection = function(host, port, options) {\n  return new WSConnection(host, port, options);\n};\n\nexports.createWSClient = createClient;\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/transport.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nmodule.exports.TBufferedTransport = require('./buffered_transport');\nmodule.exports.TFramedTransport = require('./framed_transport');\nmodule.exports.InputBufferUnderrunError = require('./input_buffer_underrun_error');\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/framed_transport.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar binary = require('./binary');\nvar InputBufferUnderrunError = require('./input_buffer_underrun_error');\n\nmodule.exports = TFramedTransport;\n\nfunction TFramedTransport(buffer, callback) {\n  this.inBuf = buffer || new Buffer(0);\n  this.outBuffers = [];\n  this.outCount = 0;\n  this.readPos = 0;\n  this.onFlush = callback;\n};\n\nTFramedTransport.receiver = function(callback, seqid) {\n  var residual = null;\n\n  return function(data) {\n    // Prepend any residual data from our previous read\n    if (residual) {\n      data = Buffer.concat([residual, data]);\n      residual = null;\n    }\n\n    // framed transport\n    while (data.length) {\n      if (data.length < 4) {\n        // Not enough bytes to continue, save and resume on next packet\n        residual = data;\n        return;\n      }\n      var frameSize = binary.readI32(data, 0);\n      if (data.length < 4 + frameSize) {\n        // Not enough bytes to continue, save and resume on next packet\n        residual = data;\n        return;\n      }\n\n      var frame = data.slice(4, 4 + frameSize);\n      residual = data.slice(4 + frameSize);\n\n      callback(new TFramedTransport(frame), seqid);\n\n      data = residual;\n      residual = null;\n    }\n  };\n};\n\nTFramedTransport.prototype.commitPosition = function(){},\nTFramedTransport.prototype.rollbackPosition = function(){},\n\n  // TODO: Implement open/close support\nTFramedTransport.prototype.isOpen = function() {\n  return true;\n};\nTFramedTransport.prototype.open = function() {};\nTFramedTransport.prototype.close =  function() {};\n\n  // Set the seqid of the message in the client\n  // So that callbacks can be found\nTFramedTransport.prototype.setCurrSeqId = function(seqid) {\n  this._seqid = seqid;\n};\n\nTFramedTransport.prototype.ensureAvailable = function(len) {\n  if (this.readPos + len > this.inBuf.length) {\n    throw new InputBufferUnderrunError();\n  }\n};\n\nTFramedTransport.prototype.read = function(len) { // this function will be used for each frames.\n  this.ensureAvailable(len);\n  var end = this.readPos + len;\n\n  if (this.inBuf.length < end) {\n    throw new Error('read(' + len + ') failed - not enough data');\n  }\n\n  var buf = this.inBuf.slice(this.readPos, end);\n  this.readPos = end;\n  return buf;\n};\n\nTFramedTransport.prototype.readByte = function() {\n  this.ensureAvailable(1);\n  return binary.readByte(this.inBuf[this.readPos++]);\n};\n\nTFramedTransport.prototype.readI16 = function() {\n  this.ensureAvailable(2);\n  var i16 = binary.readI16(this.inBuf, this.readPos);\n  this.readPos += 2;\n  return i16;\n};\n\nTFramedTransport.prototype.readI32 = function() {\n  this.ensureAvailable(4);\n  var i32 = binary.readI32(this.inBuf, this.readPos);\n  this.readPos += 4;\n  return i32;\n};\n\nTFramedTransport.prototype.readDouble = function() {\n  this.ensureAvailable(8);\n  var d = binary.readDouble(this.inBuf, this.readPos);\n  this.readPos += 8;\n  return d;\n};\n\nTFramedTransport.prototype.readString = function(len) {\n  this.ensureAvailable(len);\n  var str = this.inBuf.toString('utf8', this.readPos, this.readPos + len);\n  this.readPos += len;\n  return str;\n};\n\nTFramedTransport.prototype.borrow = function() {\n  return {\n    buf: this.inBuf,\n    readIndex: this.readPos,\n    writeIndex: this.inBuf.length\n  };\n};\n\nTFramedTransport.prototype.consume = function(bytesConsumed) {\n  this.readPos += bytesConsumed;\n};\n\nTFramedTransport.prototype.write = function(buf, encoding) {\n  if (typeof(buf) === \"string\") {\n    buf = new Buffer(buf, encoding || 'utf8');\n  }\n  this.outBuffers.push(buf);\n  this.outCount += buf.length;\n};\n\nTFramedTransport.prototype.flush = function() {\n  // If the seqid of the callback is available pass it to the onFlush\n  // Then remove the current seqid\n  var seqid = this._seqid;\n  this._seqid = null;\n\n  var out = new Buffer(this.outCount),\n      pos = 0;\n  this.outBuffers.forEach(function(buf) {\n    buf.copy(out, pos, 0);\n    pos += buf.length;\n  });\n\n  if (this.onFlush) {\n    // TODO: optimize this better, allocate one buffer instead of both:\n    var msg = new Buffer(out.length + 4);\n    binary.writeI32(msg, out.length);\n    out.copy(msg, 4, 0, out.length);\n    if (this.onFlush) {\n      // Passing seqid through this call to get it to the connection\n      this.onFlush(msg, seqid);\n    }\n  }\n\n  this.outBuffers = [];\n  this.outCount = 0;\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/protocol.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nmodule.exports.TBinaryProtocol = require('./binary_protocol');\nmodule.exports.TCompactProtocol = require('./compact_protocol');\nmodule.exports.TJSONProtocol = require('./json_protocol');\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/compact_protocol.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar log = require('./log');\nvar Int64 = require('node-int64');\nvar Thrift = require('./thrift');\nvar Type = Thrift.Type;\n\nmodule.exports = TCompactProtocol;\n\nvar POW_8 = Math.pow(2, 8);\nvar POW_24 = Math.pow(2, 24);\nvar POW_32 = Math.pow(2, 32);\nvar POW_40 = Math.pow(2, 40);\nvar POW_48 = Math.pow(2, 48);\nvar POW_52 = Math.pow(2, 52);\nvar POW_1022 = Math.pow(2, 1022);\n\n/**\n * Constructor Function for the Compact Protocol.\n * @constructor\n * @param {object} [trans] - The underlying transport to read/write.\n * @classdesc The Apache Thrift Protocol layer performs serialization\n *     of base types, the compact protocol serializes data in binary\n *     form with minimal space used for scalar values.\n */\nfunction TCompactProtocol(trans) {\n  this.trans = trans;\n  this.lastField_ = [];\n  this.lastFieldId_ = 0;\n  this.string_limit_ = 0;\n  this.string_buf_ = null;\n  this.string_buf_size_ = 0;\n  this.container_limit_ = 0;\n  this.booleanField_ = {\n    name: null,\n    hasBoolValue: false\n  };\n  this.boolValue_ = {\n    hasBoolValue: false,\n    boolValue: false\n  };\n};\n\n\n//\n// Compact Protocol Constants\n//\n\n/**\n  * Compact Protocol ID number.\n  * @readonly\n  * @const {number} PROTOCOL_ID\n  */\nTCompactProtocol.PROTOCOL_ID = -126;  //1000 0010\n\n/**\n  * Compact Protocol version number.\n  * @readonly\n  * @const {number} VERSION_N\n  */\nTCompactProtocol.VERSION_N = 1;\n\n/**\n  * Compact Protocol version mask for combining protocol version and message type in one byte.\n  * @readonly\n  * @const {number} VERSION_MASK\n  */\nTCompactProtocol.VERSION_MASK = 0x1f; //0001 1111\n\n/**\n  * Compact Protocol message type mask for combining protocol version and message type in one byte.\n  * @readonly\n  * @const {number} TYPE_MASK\n  */\nTCompactProtocol.TYPE_MASK = -32;     //1110 0000\n\n/**\n  * Compact Protocol message type bits for ensuring message type bit size.\n  * @readonly\n  * @const {number} TYPE_BITS\n  */\nTCompactProtocol.TYPE_BITS = 7; //0000 0111\n\n/**\n  * Compact Protocol message type shift amount for combining protocol version and message type in one byte.\n  * @readonly\n  * @const {number} TYPE_SHIFT_AMOUNT\n  */\nTCompactProtocol.TYPE_SHIFT_AMOUNT = 5;\n\n/**\n * Compact Protocol type IDs used to keep type data within one nibble.\n * @readonly\n * @property {number}  CT_STOP          - End of a set of fields.\n * @property {number}  CT_BOOLEAN_TRUE  - Flag for Boolean field with true value (packed field and value).\n * @property {number}  CT_BOOLEAN_FALSE - Flag for Boolean field with false value (packed field and value).\n * @property {number}  CT_BYTE          - Signed 8 bit integer.\n * @property {number}  CT_I16           - Signed 16 bit integer.\n * @property {number}  CT_I32           - Signed 32 bit integer.\n * @property {number}  CT_I64           - Signed 64 bit integer (2^53 max in JavaScript).\n * @property {number}  CT_DOUBLE        - 64 bit IEEE 854 floating point.\n * @property {number}  CT_BINARY        - Array of bytes (used for strings also).\n * @property {number}  CT_LIST          - A collection type (unordered).\n * @property {number}  CT_SET           - A collection type (unordered and without repeated values).\n * @property {number}  CT_MAP           - A collection type (map/associative-array/dictionary).\n * @property {number}  CT_STRUCT        - A multifield type.\n */\nTCompactProtocol.Types = {\n  CT_STOP:           0x00,\n  CT_BOOLEAN_TRUE:   0x01,\n  CT_BOOLEAN_FALSE:  0x02,\n  CT_BYTE:           0x03,\n  CT_I16:            0x04,\n  CT_I32:            0x05,\n  CT_I64:            0x06,\n  CT_DOUBLE:         0x07,\n  CT_BINARY:         0x08,\n  CT_LIST:           0x09,\n  CT_SET:            0x0A,\n  CT_MAP:            0x0B,\n  CT_STRUCT:         0x0C\n};\n\n/**\n * Array mapping Compact type IDs to standard Thrift type IDs.\n * @readonly\n */\nTCompactProtocol.TTypeToCType = [\n  TCompactProtocol.Types.CT_STOP,         // T_STOP\n  0,                                      // unused\n  TCompactProtocol.Types.CT_BOOLEAN_TRUE, // T_BOOL\n  TCompactProtocol.Types.CT_BYTE,         // T_BYTE\n  TCompactProtocol.Types.CT_DOUBLE,       // T_DOUBLE\n  0,                                      // unused\n  TCompactProtocol.Types.CT_I16,          // T_I16\n  0,                                      // unused\n  TCompactProtocol.Types.CT_I32,          // T_I32\n  0,                                      // unused\n  TCompactProtocol.Types.CT_I64,          // T_I64\n  TCompactProtocol.Types.CT_BINARY,       // T_STRING\n  TCompactProtocol.Types.CT_STRUCT,       // T_STRUCT\n  TCompactProtocol.Types.CT_MAP,          // T_MAP\n  TCompactProtocol.Types.CT_SET,          // T_SET\n  TCompactProtocol.Types.CT_LIST,         // T_LIST\n];\n\n\n//\n// Compact Protocol Utilities\n//\n\n/**\n * Returns the underlying transport layer.\n * @return {object} The underlying transport layer.\n */TCompactProtocol.prototype.getTransport = function() {\n  return this.trans;\n};\n\n/**\n * Lookup a Compact Protocol Type value for a given Thrift Type value.\n * N.B. Used only internally.\n * @param {number} ttype - Thrift type value\n * @returns {number} Compact protocol type value\n */\nTCompactProtocol.prototype.getCompactType = function(ttype) {\n  return TCompactProtocol.TTypeToCType[ttype];\n};\n\n/**\n * Lookup a Thrift Type value for a given Compact Protocol Type value.\n * N.B. Used only internally.\n * @param {number} type - Compact Protocol type value\n * @returns {number} Thrift Type value\n */\nTCompactProtocol.prototype.getTType = function(type) {\n  switch (type) {\n    case Type.STOP:\n      return Type.STOP;\n    case TCompactProtocol.Types.CT_BOOLEAN_FALSE:\n    case TCompactProtocol.Types.CT_BOOLEAN_TRUE:\n      return Type.BOOL;\n    case TCompactProtocol.Types.CT_BYTE:\n      return Type.BYTE;\n    case TCompactProtocol.Types.CT_I16:\n      return Type.I16;\n    case TCompactProtocol.Types.CT_I32:\n      return Type.I32;\n    case TCompactProtocol.Types.CT_I64:\n      return Type.I64;\n    case TCompactProtocol.Types.CT_DOUBLE:\n      return Type.DOUBLE;\n    case TCompactProtocol.Types.CT_BINARY:\n      return Type.STRING;\n    case TCompactProtocol.Types.CT_LIST:\n      return Type.LIST;\n    case TCompactProtocol.Types.CT_SET:\n      return Type.SET;\n    case TCompactProtocol.Types.CT_MAP:\n      return Type.MAP;\n    case TCompactProtocol.Types.CT_STRUCT:\n      return Type.STRUCT;\n    default:\n      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, \"Unknown type: \" + type);\n  }\n  return Type.STOP;\n};\n\n\n//\n// Compact Protocol write operations\n//\n\n/**\n * Send any buffered bytes to the end point.\n */\nTCompactProtocol.prototype.flush = function() {\n  return this.trans.flush();\n};\n\n/**\n * Writes an RPC message header\n * @param {string} name - The method name for the message.\n * @param {number} type - The type of message (CALL, REPLY, EXCEPTION, ONEWAY).\n * @param {number} seqid - The call sequence number (if any).\n */\nTCompactProtocol.prototype.writeMessageBegin = function(name, type, seqid) {\n  this.writeByte(TCompactProtocol.PROTOCOL_ID);\n  this.writeByte((TCompactProtocol.VERSION_N & TCompactProtocol.VERSION_MASK) |\n                     ((type << TCompactProtocol.TYPE_SHIFT_AMOUNT) & TCompactProtocol.TYPE_MASK));\n  this.writeVarint32(seqid);\n  this.writeString(name);\n\n  // Record client seqid to find callback again\n  if (this._seqid) {\n    // TODO better logging log warning\n    log.warning('SeqId already set', { 'name': name });\n  } else {\n    this._seqid = seqid;\n    this.trans.setCurrSeqId(seqid);\n  }\n};\n\nTCompactProtocol.prototype.writeMessageEnd = function() {\n};\n\nTCompactProtocol.prototype.writeStructBegin = function(name) {\n  this.lastField_.push(this.lastFieldId_);\n  this.lastFieldId_ = 0;\n};\n\nTCompactProtocol.prototype.writeStructEnd = function() {\n  this.lastFieldId_ = this.lastField_.pop();\n};\n\n/**\n * Writes a struct field header\n * @param {string} name - The field name (not written with the compact protocol).\n * @param {number} type - The field data type (a normal Thrift field Type).\n * @param {number} id - The IDL field Id.\n */\nTCompactProtocol.prototype.writeFieldBegin = function(name, type, id) {\n  if (type != Type.BOOL) {\n    return this.writeFieldBeginInternal(name, type, id, -1);\n  }\n\n  this.booleanField_.name = name;\n  this.booleanField_.fieldType = type;\n  this.booleanField_.fieldId = id;\n};\n\nTCompactProtocol.prototype.writeFieldEnd = function() {\n};\n\nTCompactProtocol.prototype.writeFieldStop = function() {\n  this.writeByte(TCompactProtocol.Types.CT_STOP);\n};\n\n/**\n * Writes a map collection header\n * @param {number} keyType - The Thrift type of the map keys.\n * @param {number} valType - The Thrift type of the map values.\n * @param {number} size - The number of k/v pairs in the map.\n */\nTCompactProtocol.prototype.writeMapBegin = function(keyType, valType, size) {\n  if (size === 0) {\n    this.writeByte(0);\n  } else {\n    this.writeVarint32(size);\n    this.writeByte(this.getCompactType(keyType) << 4 | this.getCompactType(valType));\n  }\n};\n\nTCompactProtocol.prototype.writeMapEnd = function() {\n};\n\n/**\n * Writes a list collection header\n * @param {number} elemType - The Thrift type of the list elements.\n * @param {number} size - The number of elements in the list.\n */\nTCompactProtocol.prototype.writeListBegin = function(elemType, size) {\n  this.writeCollectionBegin(elemType, size);\n};\n\nTCompactProtocol.prototype.writeListEnd = function() {\n};\n\n/**\n * Writes a set collection header\n * @param {number} elemType - The Thrift type of the set elements.\n * @param {number} size - The number of elements in the set.\n */\nTCompactProtocol.prototype.writeSetBegin = function(elemType, size) {\n  this.writeCollectionBegin(elemType, size);\n};\n\nTCompactProtocol.prototype.writeSetEnd = function() {\n};\n\nTCompactProtocol.prototype.writeBool = function(value) {\n  if (this.booleanField_.name !== null) {\n    // we haven't written the field header yet\n    this.writeFieldBeginInternal(this.booleanField_.name,\n                                 this.booleanField_.fieldType,\n                                 this.booleanField_.fieldId,\n                                 (value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE\n                                          : TCompactProtocol.Types.CT_BOOLEAN_FALSE));\n    this.booleanField_.name = null;\n  } else {\n    // we're not part of a field, so just write the value\n    this.writeByte((value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE\n                            : TCompactProtocol.Types.CT_BOOLEAN_FALSE));\n  }\n};\n\nTCompactProtocol.prototype.writeByte = function(b) {\n  this.trans.write(new Buffer([b]));\n};\n\nTCompactProtocol.prototype.writeI16 = function(i16) {\n  this.writeVarint32(this.i32ToZigzag(i16));\n};\n\nTCompactProtocol.prototype.writeI32 = function(i32) {\n  this.writeVarint32(this.i32ToZigzag(i32));\n};\n\nTCompactProtocol.prototype.writeI64 = function(i64) {\n  this.writeVarint64(this.i64ToZigzag(i64));\n};\n\n// Little-endian, unlike TBinaryProtocol\nTCompactProtocol.prototype.writeDouble = function(v) {\n  var buff = new Buffer(8);\n  var m, e, c;\n\n  buff[7] = (v < 0 ? 0x80 : 0x00);\n\n  v = Math.abs(v);\n  if (v !== v) {\n    // NaN, use QNaN IEEE format\n    m = 2251799813685248;\n    e = 2047;\n  } else if (v === Infinity) {\n    m = 0;\n    e = 2047;\n  } else {\n    e = Math.floor(Math.log(v) / Math.LN2);\n    c = Math.pow(2, -e);\n    if (v * c < 1) {\n      e--;\n      c *= 2;\n    }\n\n    if (e + 1023 >= 2047)\n    {\n      // Overflow\n      m = 0;\n      e = 2047;\n    }\n    else if (e + 1023 >= 1)\n    {\n      // Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow\n      m = (v*c-1) * POW_52;\n      e += 1023;\n    }\n    else\n    {\n      // Denormalized - also catches the '0' case, somewhat by chance\n      m = (v * POW_1022) * POW_52;\n      e = 0;\n    }\n  }\n\n  buff[6] = (e << 4) & 0xf0;\n  buff[7] |= (e >> 4) & 0x7f;\n\n  buff[0] = m & 0xff;\n  m = Math.floor(m / POW_8);\n  buff[1] = m & 0xff;\n  m = Math.floor(m / POW_8);\n  buff[2] = m & 0xff;\n  m = Math.floor(m / POW_8);\n  buff[3] = m & 0xff;\n  m >>= 8;\n  buff[4] = m & 0xff;\n  m >>= 8;\n  buff[5] = m & 0xff;\n  m >>= 8;\n  buff[6] |= m & 0x0f;\n\n  this.trans.write(buff);\n};\n\nTCompactProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {\n  if (typeof arg === 'string') {\n    this.writeVarint32(Buffer.byteLength(arg, encoding)) ;\n    this.trans.write(new Buffer(arg, encoding));\n  } else if (arg instanceof Buffer ||\n             Object.prototype.toString.call(arg) == '[object Uint8Array]') {\n    // Buffers in Node.js under Browserify may extend UInt8Array instead of\n    // defining a new object. We detect them here so we can write them\n    // correctly\n    this.writeVarint32(arg.length);\n    this.trans.write(arg);\n  } else {\n    throw new Error(name + ' called without a string/Buffer argument: ' + arg);\n  }\n};\n\nTCompactProtocol.prototype.writeString = function(arg) {\n  this.writeStringOrBinary('writeString', 'utf8', arg);\n};\n\nTCompactProtocol.prototype.writeBinary = function(arg) {\n  this.writeStringOrBinary('writeBinary', 'binary', arg);\n};\n\n\n//\n// Compact Protocol internal write methods\n//\n\nTCompactProtocol.prototype.writeFieldBeginInternal = function(name,\n                                                              fieldType,\n                                                              fieldId,\n                                                              typeOverride) {\n  //If there's a type override, use that.\n  var typeToWrite = (typeOverride == -1 ? this.getCompactType(fieldType) : typeOverride);\n  //Check if we can delta encode the field id\n  if (fieldId > this.lastFieldId_ && fieldId - this.lastFieldId_ <= 15) {\n    //Include the type delta with the field ID\n    this.writeByte((fieldId - this.lastFieldId_) << 4 | typeToWrite);\n  } else {\n    //Write separate type and ID values\n    this.writeByte(typeToWrite);\n    this.writeI16(fieldId);\n  }\n  this.lastFieldId_ = fieldId;\n};\n\nTCompactProtocol.prototype.writeCollectionBegin = function(elemType, size) {\n  if (size <= 14) {\n    //Combine size and type in one byte if possible\n    this.writeByte(size << 4 | this.getCompactType(elemType));\n  } else {\n    this.writeByte(0xf0 | this.getCompactType(elemType));\n    this.writeVarint32(size);\n  }\n};\n\n/**\n * Write an i32 as a varint. Results in 1-5 bytes on the wire.\n */\nTCompactProtocol.prototype.writeVarint32 = function(n) {\n  var buf = new Buffer(5);\n  var wsize = 0;\n  while (true) {\n    if ((n & ~0x7F) === 0) {\n      buf[wsize++] = n;\n      break;\n    } else {\n      buf[wsize++] = ((n & 0x7F) | 0x80);\n      n = n >>> 7;\n    }\n  }\n  var wbuf = new Buffer(wsize);\n  buf.copy(wbuf,0,0,wsize);\n  this.trans.write(wbuf);\n};\n\n/**\n * Write an i64 as a varint. Results in 1-10 bytes on the wire.\n * N.B. node-int64 is always big endian\n */\nTCompactProtocol.prototype.writeVarint64 = function(n) {\n  if (typeof n === \"number\"){\n    n = new Int64(n);\n  }\n  if (! (n instanceof Int64)) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, \"Expected Int64 or Number, found: \" + n);\n  }\n\n  var buf = new Buffer(10);\n  var wsize = 0;\n  var hi = n.buffer.readUInt32BE(0, true);\n  var lo = n.buffer.readUInt32BE(4, true);\n  var mask = 0;\n  while (true) {\n    if (((lo & ~0x7F) === 0) && (hi === 0)) {\n      buf[wsize++] = lo;\n      break;\n    } else {\n      buf[wsize++] = ((lo & 0x7F) | 0x80);\n      mask = hi << 25;\n      lo = lo >>> 7;\n      hi = hi >>> 7;\n      lo = lo | mask;\n    }\n  }\n  var wbuf = new Buffer(wsize);\n  buf.copy(wbuf,0,0,wsize);\n  this.trans.write(wbuf);\n};\n\n/**\n * Convert l into a zigzag long. This allows negative numbers to be\n * represented compactly as a varint.\n */\nTCompactProtocol.prototype.i64ToZigzag = function(l) {\n  if (typeof l === 'string') {\n    l = new Int64(parseInt(l, 10));\n  } else if (typeof l === 'number') {\n    l = new Int64(l);\n  }\n  if (! (l instanceof Int64)) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, \"Expected Int64 or Number, found: \" + l);\n  }\n  var hi = l.buffer.readUInt32BE(0, true);\n  var lo = l.buffer.readUInt32BE(4, true);\n  var sign = hi >>> 31;\n  hi = ((hi << 1) | (lo >>> 31)) ^ ((!!sign) ? 0xFFFFFFFF : 0);\n  lo = (lo << 1) ^ ((!!sign) ? 0xFFFFFFFF : 0);\n  return new Int64(hi, lo);\n};\n\n/**\n * Convert n into a zigzag int. This allows negative numbers to be\n * represented compactly as a varint.\n */\nTCompactProtocol.prototype.i32ToZigzag = function(n) {\n  return (n << 1) ^ ((n & 0x80000000) ? 0xFFFFFFFF : 0);\n};\n\n\n//\n// Compact Protocol read operations\n//\n\nTCompactProtocol.prototype.readMessageBegin = function() {\n  //Read protocol ID\n  var protocolId = this.trans.readByte();\n  if (protocolId != TCompactProtocol.PROTOCOL_ID) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, \"Bad protocol identifier \" + protocolId);\n  }\n\n  //Read Version and Type\n  var versionAndType = this.trans.readByte();\n  var version = (versionAndType & TCompactProtocol.VERSION_MASK);\n  if (version != TCompactProtocol.VERSION_N) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, \"Bad protocol version \" + version);\n  }\n  var type = ((versionAndType >> TCompactProtocol.TYPE_SHIFT_AMOUNT) & TCompactProtocol.TYPE_BITS);\n\n  //Read SeqId\n  var seqid = this.readVarint32();\n\n  //Read name\n  var name = this.readString();\n\n  return {fname: name, mtype: type, rseqid: seqid};\n};\n\nTCompactProtocol.prototype.readMessageEnd = function() {\n};\n\nTCompactProtocol.prototype.readStructBegin = function() {\n  this.lastField_.push(this.lastFieldId_);\n  this.lastFieldId_ = 0;\n  return {fname: ''};\n};\n\nTCompactProtocol.prototype.readStructEnd = function() {\n  this.lastFieldId_ = this.lastField_.pop();\n};\n\nTCompactProtocol.prototype.readFieldBegin = function() {\n  var fieldId = 0;\n  var b = this.trans.readByte(b);\n  var type = (b & 0x0f);\n\n  if (type == TCompactProtocol.Types.CT_STOP) {\n    return {fname: null, ftype: Thrift.Type.STOP, fid: 0};\n  }\n\n  //Mask off the 4 MSB of the type header to check for field id delta.\n  var modifier = ((b & 0x000000f0) >>> 4);\n  if (modifier === 0) {\n    //If not a delta read the field id.\n    fieldId = this.readI16();\n  } else {\n    //Recover the field id from the delta\n    fieldId = (this.lastFieldId_ + modifier);\n  }\n  var fieldType = this.getTType(type);\n\n  //Boolean are encoded with the type\n  if (type == TCompactProtocol.Types.CT_BOOLEAN_TRUE ||\n      type == TCompactProtocol.Types.CT_BOOLEAN_FALSE) {\n    this.boolValue_.hasBoolValue = true;\n    this.boolValue_.boolValue =\n      (type == TCompactProtocol.Types.CT_BOOLEAN_TRUE ? true : false);\n  }\n\n  //Save the new field for the next delta computation.\n  this.lastFieldId_ = fieldId;\n  return {fname: null, ftype: fieldType, fid: fieldId};\n};\n\nTCompactProtocol.prototype.readFieldEnd = function() {\n};\n\nTCompactProtocol.prototype.readMapBegin = function() {\n  var msize = this.readVarint32();\n  if (msize < 0) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, \"Negative map size\");\n  }\n\n  var kvType = 0;\n  if (msize !== 0) {\n    kvType = this.trans.readByte();\n  }\n\n  var keyType = this.getTType((kvType & 0xf0) >>> 4);\n  var valType = this.getTType(kvType & 0xf);\n  return {ktype: keyType, vtype: valType, size: msize};\n};\n\nTCompactProtocol.prototype.readMapEnd = function() {\n};\n\nTCompactProtocol.prototype.readListBegin = function() {\n  var size_and_type = this.trans.readByte();\n\n  var lsize = (size_and_type >>> 4) & 0x0000000f;\n  if (lsize == 15) {\n    lsize = this.readVarint32();\n  }\n\n  if (lsize < 0) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, \"Negative list size\");\n  }\n\n  var elemType = this.getTType(size_and_type & 0x0000000f);\n\n  return {etype: elemType, size: lsize};\n};\n\nTCompactProtocol.prototype.readListEnd = function() {\n};\n\nTCompactProtocol.prototype.readSetBegin = function() {\n  return this.readListBegin();\n};\n\nTCompactProtocol.prototype.readSetEnd = function() {\n};\n\nTCompactProtocol.prototype.readBool = function() {\n  var value = false;\n  var rsize = 0;\n  if (this.boolValue_.hasBoolValue === true) {\n    value = this.boolValue_.boolValue;\n    this.boolValue_.hasBoolValue = false;\n  } else {\n    var res = this.trans.readByte();\n    rsize = res.rsize;\n    value = (res.value == TCompactProtocol.Types.CT_BOOLEAN_TRUE);\n  }\n  return value;\n};\n\nTCompactProtocol.prototype.readByte = function() {\n  return this.trans.readByte();\n};\n\nTCompactProtocol.prototype.readI16 = function() {\n  return this.readI32();\n};\n\nTCompactProtocol.prototype.readI32 = function() {\n  return this.zigzagToI32(this.readVarint32());\n};\n\nTCompactProtocol.prototype.readI64 = function() {\n  return this.zigzagToI64(this.readVarint64());\n};\n\n// Little-endian, unlike TBinaryProtocol\nTCompactProtocol.prototype.readDouble = function() {\n  var buff = this.trans.read(8);\n  var off = 0;\n\n  var signed = buff[off + 7] & 0x80;\n  var e = (buff[off+6] & 0xF0) >> 4;\n  e += (buff[off+7] & 0x7F) << 4;\n\n  var m = buff[off];\n  m += buff[off+1] << 8;\n  m += buff[off+2] << 16;\n  m += buff[off+3] * POW_24;\n  m += buff[off+4] * POW_32;\n  m += buff[off+5] * POW_40;\n  m += (buff[off+6] & 0x0F) * POW_48;\n\n  switch (e) {\n    case 0:\n      e = -1022;\n      break;\n    case 2047:\n      return m ? NaN : (signed ? -Infinity : Infinity);\n    default:\n      m += POW_52;\n      e -= 1023;\n  }\n\n  if (signed) {\n    m *= -1;\n  }\n\n  return m * Math.pow(2, e - 52);\n};\n\nTCompactProtocol.prototype.readBinary = function() {\n  var size = this.readVarint32();\n  if (size === 0) {\n    return new Buffer(0);\n  }\n\n  if (size < 0) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, \"Negative binary size\");\n  }\n  return this.trans.read(size);\n};\n\nTCompactProtocol.prototype.readString = function() {\n  var size = this.readVarint32();\n  // Catch empty string case\n  if (size === 0) {\n    return \"\";\n  }\n\n  // Catch error cases\n  if (size < 0) {\n    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, \"Negative string size\");\n  }\n  return this.trans.readString(size);\n};\n\n\n//\n// Compact Protocol internal read operations\n//\n\n/**\n * Read an i32 from the wire as a varint. The MSB of each byte is set\n * if there is another byte to follow. This can read up to 5 bytes.\n */\nTCompactProtocol.prototype.readVarint32 = function() {\n  return this.readVarint64().toNumber();\n};\n\n/**\n * Read an i64 from the wire as a proper varint. The MSB of each byte is set\n * if there is another byte to follow. This can read up to 10 bytes.\n */\nTCompactProtocol.prototype.readVarint64 = function() {\n  var rsize = 0;\n  var lo = 0;\n  var hi = 0;\n  var shift = 0;\n  while (true) {\n    var b = this.trans.readByte();\n    rsize ++;\n    if (shift <= 25) {\n      lo = lo | ((b & 0x7f) << shift);\n    } else if (25 < shift && shift < 32) {\n      lo = lo | ((b & 0x7f) << shift);\n      hi = hi | ((b & 0x7f) >>> (32-shift));\n    } else {\n      hi = hi | ((b & 0x7f) << (shift-32));\n    }\n    shift += 7;\n    if (!(b & 0x80)) {\n      break;\n    }\n    if (rsize >= 10) {\n      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, \"Variable-length int over 10 bytes.\");\n    }\n  }\n  return new Int64(hi, lo);\n};\n\n/**\n * Convert from zigzag int to int.\n */\nTCompactProtocol.prototype.zigzagToI32 = function(n) {\n  return (n >>> 1) ^ (-1 * (n & 1));\n};\n\n/**\n * Convert from zigzag long to long.\n */\nTCompactProtocol.prototype.zigzagToI64 = function(n) {\n  var hi = n.buffer.readUInt32BE(0, true);\n  var lo = n.buffer.readUInt32BE(4, true);\n\n  var neg = new Int64(hi & 0, lo & 1);\n  neg._2scomp();\n  var hi_neg = neg.buffer.readUInt32BE(0, true);\n  var lo_neg = neg.buffer.readUInt32BE(4, true);\n\n  var hi_lo = (hi << 31);\n  hi = (hi >>> 1) ^ (hi_neg);\n  lo = ((lo >>> 1) | hi_lo) ^ (lo_neg);\n  return new Int64(hi, lo);\n};\n\nTCompactProtocol.prototype.skip = function(type) {\n  switch (type) {\n    case Type.STOP:\n      return;\n    case Type.BOOL:\n      this.readBool();\n      break;\n    case Type.BYTE:\n      this.readByte();\n      break;\n    case Type.I16:\n      this.readI16();\n      break;\n    case Type.I32:\n      this.readI32();\n      break;\n    case Type.I64:\n      this.readI64();\n      break;\n    case Type.DOUBLE:\n      this.readDouble();\n      break;\n    case Type.STRING:\n      this.readString();\n      break;\n    case Type.STRUCT:\n      this.readStructBegin();\n      while (true) {\n        var r = this.readFieldBegin();\n        if (r.ftype === Type.STOP) {\n          break;\n        }\n        this.skip(r.ftype);\n        this.readFieldEnd();\n      }\n      this.readStructEnd();\n      break;\n    case Type.MAP:\n      var mapBegin = this.readMapBegin();\n      for (var i = 0; i < mapBegin.size; ++i) {\n        this.skip(mapBegin.ktype);\n        this.skip(mapBegin.vtype);\n      }\n      this.readMapEnd();\n      break;\n    case Type.SET:\n      var setBegin = this.readSetBegin();\n      for (var i2 = 0; i2 < setBegin.size; ++i2) {\n        this.skip(setBegin.etype);\n      }\n      this.readSetEnd();\n      break;\n    case Type.LIST:\n      var listBegin = this.readListBegin();\n      for (var i3 = 0; i3 < listBegin.size; ++i3) {\n        this.skip(listBegin.etype);\n      }\n      this.readListEnd();\n      break;\n    default:\n      throw new  Error(\"Invalid type: \" + type);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/json_protocol.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar log = require('./log');\nvar Int64 = require('node-int64');\nvar InputBufferUnderrunError = require('./transport').InputBufferUnderrunError;\nvar Thrift = require('./thrift');\nvar Type = Thrift.Type;\nvar util = require(\"util\");\n\nvar Int64Util = require('./int64_util');\nvar json_parse = require('./json_parse');\n\nvar InputBufferUnderrunError = require('./input_buffer_underrun_error');\n\nmodule.exports = TJSONProtocol;\n\n/**\n * Initializes a Thrift JSON protocol instance.\n * @constructor\n * @param {Thrift.Transport} trans - The transport to serialize to/from.\n * @classdesc Apache Thrift Protocols perform serialization which enables cross\n * language RPC. The Protocol type is the JavaScript browser implementation\n * of the Apache Thrift TJSONProtocol.\n * @example\n *     var protocol  = new Thrift.Protocol(transport);\n */\nfunction TJSONProtocol(trans) {\n  this.tstack = [];\n  this.tpos = [];\n  this.trans = trans;\n};\n\n/**\n * Thrift IDL type Id to string mapping.\n * @readonly\n * @see {@link Thrift.Type}\n */\nTJSONProtocol.Type = {};\nTJSONProtocol.Type[Type.BOOL] = '\"tf\"';\nTJSONProtocol.Type[Type.BYTE] = '\"i8\"';\nTJSONProtocol.Type[Type.I16] = '\"i16\"';\nTJSONProtocol.Type[Type.I32] = '\"i32\"';\nTJSONProtocol.Type[Type.I64] = '\"i64\"';\nTJSONProtocol.Type[Type.DOUBLE] = '\"dbl\"';\nTJSONProtocol.Type[Type.STRUCT] = '\"rec\"';\nTJSONProtocol.Type[Type.STRING] = '\"str\"';\nTJSONProtocol.Type[Type.MAP] = '\"map\"';\nTJSONProtocol.Type[Type.LIST] = '\"lst\"';\nTJSONProtocol.Type[Type.SET] = '\"set\"';\n\n/**\n * Thrift IDL type string to Id mapping.\n * @readonly\n * @see {@link Thrift.Type}\n */\nTJSONProtocol.RType = {};\nTJSONProtocol.RType.tf = Type.BOOL;\nTJSONProtocol.RType.i8 = Type.BYTE;\nTJSONProtocol.RType.i16 = Type.I16;\nTJSONProtocol.RType.i32 = Type.I32;\nTJSONProtocol.RType.i64 = Type.I64;\nTJSONProtocol.RType.dbl = Type.DOUBLE;\nTJSONProtocol.RType.rec = Type.STRUCT;\nTJSONProtocol.RType.str = Type.STRING;\nTJSONProtocol.RType.map = Type.MAP;\nTJSONProtocol.RType.lst = Type.LIST;\nTJSONProtocol.RType.set = Type.SET;\n\n/**\n * The TJSONProtocol version number.\n * @readonly\n * @const {number} Version\n * @memberof Thrift.Protocol\n */\nTJSONProtocol.Version = 1;\n\nTJSONProtocol.prototype.flush = function() {\n  this.writeToTransportIfStackIsFlushable();\n  return this.trans.flush();\n};\n\nTJSONProtocol.prototype.writeToTransportIfStackIsFlushable = function() {\n  if (this.tstack.length === 1) {\n    this.trans.write(this.tstack.pop());\n  }\n};\n\n/**\n * Serializes the beginning of a Thrift RPC message.\n * @param {string} name - The service method to call.\n * @param {Thrift.MessageType} messageType - The type of method call.\n * @param {number} seqid - The sequence number of this call (always 0 in Apache Thrift).\n */\nTJSONProtocol.prototype.writeMessageBegin = function(name, messageType, seqid) {\n  this.tstack.push([TJSONProtocol.Version, '\"' + name + '\"', messageType, seqid]);\n};\n\n/**\n * Serializes the end of a Thrift RPC message.\n */\nTJSONProtocol.prototype.writeMessageEnd = function() {\n  var obj = this.tstack.pop();\n\n  this.wobj = this.tstack.pop();\n  this.wobj.push(obj);\n\n  this.wbuf = '[' + this.wobj.join(',') + ']';\n\n  // we assume there is nothing more to come so we write\n  this.trans.write(this.wbuf);\n};\n\n/**\n * Serializes the beginning of a struct.\n * @param {string} name - The name of the struct.\n */\nTJSONProtocol.prototype.writeStructBegin = function(name) {\n  this.tpos.push(this.tstack.length);\n  this.tstack.push({});\n};\n\n/**\n * Serializes the end of a struct.\n */\nTJSONProtocol.prototype.writeStructEnd = function() {\n  var p = this.tpos.pop();\n  var struct = this.tstack[p];\n  var str = '{';\n  var first = true;\n  for (var key in struct) {\n    if (first) {\n      first = false;\n    } else {\n      str += ',';\n    }\n\n    str += key + ':' + struct[key];\n  }\n\n  str += '}';\n  this.tstack[p] = str;\n\n  this.writeToTransportIfStackIsFlushable();\n};\n\n/**\n * Serializes the beginning of a struct field.\n * @param {string} name - The name of the field.\n * @param {Thrift.Protocol.Type} fieldType - The data type of the field.\n * @param {number} fieldId - The field's unique identifier.\n */\nTJSONProtocol.prototype.writeFieldBegin = function(name, fieldType, fieldId) {\n  this.tpos.push(this.tstack.length);\n  this.tstack.push({ 'fieldId': '\"' +\n    fieldId + '\"', 'fieldType': TJSONProtocol.Type[fieldType]\n  });\n};\n\n/**\n * Serializes the end of a field.\n */\nTJSONProtocol.prototype.writeFieldEnd = function() {\n  var value = this.tstack.pop();\n  var fieldInfo = this.tstack.pop();\n\n  if (':' + value === \":[object Object]\") {\n    this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +\n      fieldInfo.fieldType + ':' + JSON.stringify(value) + '}';\n  } else {\n    this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +\n      fieldInfo.fieldType + ':' + value + '}';\n  }\n  this.tpos.pop();\n\n  this.writeToTransportIfStackIsFlushable();\n};\n\n/**\n * Serializes the end of the set of fields for a struct.\n */\nTJSONProtocol.prototype.writeFieldStop = function() {\n};\n\n/**\n * Serializes the beginning of a map collection.\n * @param {Thrift.Type} keyType - The data type of the key.\n * @param {Thrift.Type} valType - The data type of the value.\n * @param {number} [size] - The number of elements in the map (ignored).\n */\nTJSONProtocol.prototype.writeMapBegin = function(keyType, valType, size) {\n  //size is invalid, we'll set it on end.\n  this.tpos.push(this.tstack.length);\n  this.tstack.push([TJSONProtocol.Type[keyType], TJSONProtocol.Type[valType], 0]);\n};\n\n/**\n * Serializes the end of a map.\n */\nTJSONProtocol.prototype.writeMapEnd = function() {\n  var p = this.tpos.pop();\n\n  if (p == this.tstack.length) {\n    return;\n  }\n\n  if ((this.tstack.length - p - 1) % 2 !== 0) {\n    this.tstack.push('');\n  }\n\n  var size = (this.tstack.length - p - 1) / 2;\n\n  this.tstack[p][this.tstack[p].length - 1] = size;\n\n  var map = '}';\n  var first = true;\n  while (this.tstack.length > p + 1) {\n    var v = this.tstack.pop();\n    var k = this.tstack.pop();\n    if (first) {\n      first = false;\n    } else {\n      map = ',' + map;\n    }\n\n    if (! isNaN(k)) { k = '\"' + k + '\"'; } //json \"keys\" need to be strings\n    map = k + ':' + v + map;\n  }\n  map = '{' + map;\n\n  this.tstack[p].push(map);\n  this.tstack[p] = '[' + this.tstack[p].join(',') + ']';\n\n  this.writeToTransportIfStackIsFlushable();\n};\n\n/**\n * Serializes the beginning of a list collection.\n * @param {Thrift.Type} elemType - The data type of the elements.\n * @param {number} size - The number of elements in the list.\n */\nTJSONProtocol.prototype.writeListBegin = function(elemType, size) {\n  this.tpos.push(this.tstack.length);\n  this.tstack.push([TJSONProtocol.Type[elemType], size]);\n};\n\n/**\n * Serializes the end of a list.\n */\nTJSONProtocol.prototype.writeListEnd = function() {\n  var p = this.tpos.pop();\n\n  while (this.tstack.length > p + 1) {\n    var tmpVal = this.tstack[p + 1];\n    this.tstack.splice(p + 1, 1);\n    this.tstack[p].push(tmpVal);\n  }\n\n  this.tstack[p] = '[' + this.tstack[p].join(',') + ']';\n\n  this.writeToTransportIfStackIsFlushable();\n};\n\n/**\n * Serializes the beginning of a set collection.\n * @param {Thrift.Type} elemType - The data type of the elements.\n * @param {number} size - The number of elements in the list.\n */\nTJSONProtocol.prototype.writeSetBegin = function(elemType, size) {\n    this.tpos.push(this.tstack.length);\n    this.tstack.push([TJSONProtocol.Type[elemType], size]);\n};\n\n/**\n * Serializes the end of a set.\n */\nTJSONProtocol.prototype.writeSetEnd = function() {\n  var p = this.tpos.pop();\n\n  while (this.tstack.length > p + 1) {\n    var tmpVal = this.tstack[p + 1];\n    this.tstack.splice(p + 1, 1);\n    this.tstack[p].push(tmpVal);\n  }\n\n  this.tstack[p] = '[' + this.tstack[p].join(',') + ']';\n\n  this.writeToTransportIfStackIsFlushable();\n};\n\n/** Serializes a boolean */\nTJSONProtocol.prototype.writeBool = function(bool) {\n  this.tstack.push(bool ? 1 : 0);\n};\n\n/** Serializes a number */\nTJSONProtocol.prototype.writeByte = function(byte) {\n  this.tstack.push(byte);\n};\n\n/** Serializes a number */\nTJSONProtocol.prototype.writeI16 = function(i16) {\n  this.tstack.push(i16);\n};\n\n/** Serializes a number */\nTJSONProtocol.prototype.writeI32 = function(i32) {\n  this.tstack.push(i32);\n};\n\n/** Serializes a number */\nTJSONProtocol.prototype.writeI64 = function(i64) {\n  if (i64 instanceof Int64) {\n    this.tstack.push(Int64Util.toDecimalString(i64));\n  } else {\n    this.tstack.push(i64);\n  }\n};\n\n/** Serializes a number */\nTJSONProtocol.prototype.writeDouble = function(dub) {\n  this.tstack.push(dub);\n};\n\n/** Serializes a string */\nTJSONProtocol.prototype.writeString = function(arg) {\n  // We do not encode uri components for wire transfer:\n  if (arg === null) {\n      this.tstack.push(null);\n  } else {\n      if (typeof arg === 'string') {\n        var str = arg;\n      } else if (arg instanceof Buffer) {\n        var str = arg.toString('utf8');\n      } else {\n        throw new Error('writeString called without a string/Buffer argument: ' + arg);\n      }\n\n      // concat may be slower than building a byte buffer\n      var escapedString = '';\n      for (var i = 0; i < str.length; i++) {\n          var ch = str.charAt(i);      // a single double quote: \"\n          if (ch === '\\\"') {\n              escapedString += '\\\\\\\"'; // write out as: \\\"\n          } else if (ch === '\\\\') {    // a single backslash: \\\n              escapedString += '\\\\\\\\'; // write out as: \\\\\n          /* Currently escaped forward slashes break TJSONProtocol.\n           * As it stands, we can simply pass forward slashes into\n           * our strings across the wire without being escaped.\n           * I think this is the protocol's bug, not thrift.js\n           * } else if(ch === '/') {   // a single forward slash: /\n           *  escapedString += '\\\\/';  // write out as \\/\n           * }\n           */\n          } else if (ch === '\\b') {    // a single backspace: invisible\n              escapedString += '\\\\b';  // write out as: \\b\"\n          } else if (ch === '\\f') {    // a single formfeed: invisible\n              escapedString += '\\\\f';  // write out as: \\f\"\n          } else if (ch === '\\n') {    // a single newline: invisible\n              escapedString += '\\\\n';  // write out as: \\n\"\n          } else if (ch === '\\r') {    // a single return: invisible\n              escapedString += '\\\\r';  // write out as: \\r\"\n          } else if (ch === '\\t') {    // a single tab: invisible\n              escapedString += '\\\\t';  // write out as: \\t\"\n          } else {\n              escapedString += ch;     // Else it need not be escaped\n          }\n      }\n      this.tstack.push('\"' + escapedString + '\"');\n  }\n};\n\n/** Serializes a string */\nTJSONProtocol.prototype.writeBinary = function(arg) {\n  if (typeof arg === 'string') {\n    var buf = new Buffer(arg, 'binary');\n  } else if (arg instanceof Buffer ||\n             Object.prototype.toString.call(arg) == '[object Uint8Array]')  {\n    var buf = arg;\n  } else {\n    throw new Error('writeBinary called without a string/Buffer argument: ' + arg);\n  }\n  this.tstack.push('\"' + buf.toString('base64') + '\"');\n};\n\n/**\n * @class\n * @name AnonReadMessageBeginReturn\n * @property {string} fname - The name of the service method.\n * @property {Thrift.MessageType} mtype - The type of message call.\n * @property {number} rseqid - The sequence number of the message (0 in Thrift RPC).\n */\n/**\n * Deserializes the beginning of a message.\n * @returns {AnonReadMessageBeginReturn}\n */\nTJSONProtocol.prototype.readMessageBegin = function() {\n  this.rstack = [];\n  this.rpos = [];\n\n  //Borrow the inbound transport buffer and ensure data is present/consistent\n  var transBuf = this.trans.borrow();\n  if (transBuf.readIndex >= transBuf.writeIndex) {\n    throw new InputBufferUnderrunError();\n  }\n  var cursor = transBuf.readIndex;\n\n  if (transBuf.buf[cursor] !== 0x5B) { //[\n    throw new Error(\"Malformed JSON input, no opening bracket\");\n  }\n\n  //Parse a single message (there may be several in the buffer)\n  //  TODO: Handle characters using multiple code units\n  cursor++;\n  var openBracketCount = 1;\n  var inString = false;\n  for (; cursor < transBuf.writeIndex; cursor++) {\n    var chr = transBuf.buf[cursor];\n    //we use hexa charcode here because data[i] returns an int and not a char\n    if (inString) {\n      if (chr === 0x22) { //\"\n        inString = false;\n      } else if (chr === 0x5C) { //\\\n        //escaped character, skip\n        cursor += 1;\n      }\n    } else {\n      if (chr === 0x5B) { //[\n        openBracketCount += 1;\n      } else if (chr === 0x5D) { //]\n        openBracketCount -= 1;\n        if (openBracketCount === 0) {\n          //end of json message detected\n          break;\n        }\n      } else if (chr === 0x22) { //\"\n        inString = true;\n      }\n    }\n  }\n\n  if (openBracketCount !== 0) {\n    // Missing closing bracket. Can be buffer underrun.\n    throw new InputBufferUnderrunError();\n  }\n\n  //Reconstitute the JSON object and conume the necessary bytes\n  this.robj = json_parse(transBuf.buf.slice(transBuf.readIndex, cursor+1).toString());\n  this.trans.consume(cursor + 1 - transBuf.readIndex);\n\n  //Verify the protocol version\n  var version = this.robj.shift();\n  if (version != TJSONProtocol.Version) {\n    throw new Error('Wrong thrift protocol version: ' + version);\n  }\n\n  //Objectify the thrift message {name/type/sequence-number} for return\n  // and then save the JSON object in rstack\n  var r = {};\n  r.fname = this.robj.shift();\n  r.mtype = this.robj.shift();\n  r.rseqid = this.robj.shift();\n  this.rstack.push(this.robj.shift());\n  return r;\n};\n\n/** Deserializes the end of a message. */\nTJSONProtocol.prototype.readMessageEnd = function() {\n};\n\n/**\n * Deserializes the beginning of a struct.\n * @param {string} [name] - The name of the struct (ignored)\n * @returns {object} - An object with an empty string fname property\n */\nTJSONProtocol.prototype.readStructBegin = function() {\n  var r = {};\n  r.fname = '';\n\n  //incase this is an array of structs\n  if (this.rstack[this.rstack.length - 1] instanceof Array) {\n    this.rstack.push(this.rstack[this.rstack.length - 1].shift());\n  }\n\n  return r;\n};\n\n/** Deserializes the end of a struct. */\nTJSONProtocol.prototype.readStructEnd = function() {\n  this.rstack.pop();\n};\n\n/**\n * @class\n * @name AnonReadFieldBeginReturn\n * @property {string} fname - The name of the field (always '').\n * @property {Thrift.Type} ftype - The data type of the field.\n * @property {number} fid - The unique identifier of the field.\n */\n/**\n * Deserializes the beginning of a field.\n * @returns {AnonReadFieldBeginReturn}\n */\nTJSONProtocol.prototype.readFieldBegin = function() {\n  var r = {};\n\n  var fid = -1;\n  var ftype = Type.STOP;\n\n  //get a fieldId\n  for (var f in (this.rstack[this.rstack.length - 1])) {\n    if (f === null) {\n      continue;\n    }\n\n    fid = parseInt(f, 10);\n    this.rpos.push(this.rstack.length);\n\n    var field = this.rstack[this.rstack.length - 1][fid];\n\n    //remove so we don't see it again\n    delete this.rstack[this.rstack.length - 1][fid];\n\n    this.rstack.push(field);\n\n    break;\n  }\n\n  if (fid != -1) {\n    //should only be 1 of these but this is the only\n    //way to match a key\n    for (var i in (this.rstack[this.rstack.length - 1])) {\n      if (TJSONProtocol.RType[i] === null) {\n        continue;\n      }\n\n      ftype = TJSONProtocol.RType[i];\n      this.rstack[this.rstack.length - 1] = this.rstack[this.rstack.length - 1][i];\n    }\n  }\n\n  r.fname = '';\n  r.ftype = ftype;\n  r.fid = fid;\n\n  return r;\n};\n\n/** Deserializes the end of a field. */\nTJSONProtocol.prototype.readFieldEnd = function() {\n  var pos = this.rpos.pop();\n\n  //get back to the right place in the stack\n  while (this.rstack.length > pos) {\n    this.rstack.pop();\n  }\n};\n\n/**\n * @class\n * @name AnonReadMapBeginReturn\n * @property {Thrift.Type} ktype - The data type of the key.\n * @property {Thrift.Type} vtype - The data type of the value.\n * @property {number} size - The number of elements in the map.\n */\n/**\n * Deserializes the beginning of a map.\n * @returns {AnonReadMapBeginReturn}\n */\nTJSONProtocol.prototype.readMapBegin = function() {\n  var map = this.rstack.pop();\n  var first = map.shift();\n  if (first instanceof Array) {\n    this.rstack.push(map);\n    map = first;\n    first = map.shift();\n  }\n\n  var r = {};\n  r.ktype = TJSONProtocol.RType[first];\n  r.vtype = TJSONProtocol.RType[map.shift()];\n  r.size = map.shift();\n\n\n  this.rpos.push(this.rstack.length);\n  this.rstack.push(map.shift());\n\n  return r;\n};\n\n/** Deserializes the end of a map. */\nTJSONProtocol.prototype.readMapEnd = function() {\n  this.readFieldEnd();\n};\n\n/**\n * @class\n * @name AnonReadColBeginReturn\n * @property {Thrift.Type} etype - The data type of the element.\n * @property {number} size - The number of elements in the collection.\n */\n/**\n * Deserializes the beginning of a list.\n * @returns {AnonReadColBeginReturn}\n */\nTJSONProtocol.prototype.readListBegin = function() {\n  var list = this.rstack[this.rstack.length - 1];\n\n  var r = {};\n  r.etype = TJSONProtocol.RType[list.shift()];\n  r.size = list.shift();\n\n  this.rpos.push(this.rstack.length);\n  this.rstack.push(list.shift());\n\n  return r;\n};\n\n/** Deserializes the end of a list. */\nTJSONProtocol.prototype.readListEnd = function() {\n  var pos = this.rpos.pop() - 2;\n  var st = this.rstack;\n  st.pop();\n  if (st instanceof Array && st.length > pos && st[pos].length > 0) {\n    st.push(st[pos].shift());\n  }\n};\n\n/**\n * Deserializes the beginning of a set.\n * @returns {AnonReadColBeginReturn}\n */\nTJSONProtocol.prototype.readSetBegin = function() {\n  return this.readListBegin();\n};\n\n/** Deserializes the end of a set. */\nTJSONProtocol.prototype.readSetEnd = function() {\n  return this.readListEnd();\n};\n\nTJSONProtocol.prototype.readBool = function() {\n  return this.readValue() == '1';\n};\n\nTJSONProtocol.prototype.readByte = function() {\n  return this.readI32();\n};\n\nTJSONProtocol.prototype.readI16 = function() {\n  return this.readI32();\n};\n\nTJSONProtocol.prototype.readI32 = function(f) {\n  return +this.readValue();\n}\n\n/** Returns the next value found in the protocol buffer */\nTJSONProtocol.prototype.readValue = function(f) {\n  if (f === undefined) {\n    f = this.rstack[this.rstack.length - 1];\n  }\n\n  var r = {};\n\n  if (f instanceof Array) {\n    if (f.length === 0) {\n      r.value = undefined;\n    } else {\n      r.value = f.shift();\n    }\n  } else if (!(f instanceof Int64) && f instanceof Object) {\n    for (var i in f) {\n      if (i === null) {\n        continue;\n      }\n      this.rstack.push(f[i]);\n      delete f[i];\n\n      r.value = i;\n      break;\n    }\n  } else {\n    r.value = f;\n    this.rstack.pop();\n  }\n\n  return r.value;\n};\n\nTJSONProtocol.prototype.readI64 = function() {\n  var n = this.readValue()\n  if (typeof n === 'string') {\n    // Assuming no one is sending in 1.11111e+33 format\n    return Int64Util.fromDecimalString(n);\n  } else {\n    return new Int64(n);\n  }\n};\n\nTJSONProtocol.prototype.readDouble = function() {\n  return this.readI32();\n};\n\nTJSONProtocol.prototype.readBinary = function() {\n  return new Buffer(this.readValue(), 'base64');\n};\n\nTJSONProtocol.prototype.readString = function() {\n  return this.readValue();\n};\n\n/**\n * Returns the underlying transport.\n * @readonly\n * @returns {Thrift.Transport} The underlying transport.\n */\nTJSONProtocol.prototype.getTransport = function() {\n  return this.trans;\n};\n\n/**\n * Method to arbitrarily skip over data\n */\nTJSONProtocol.prototype.skip = function(type) {\n  throw new Error('skip not supported yet');\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/int64_util.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar Int64 = require('node-int64');\n\nvar Int64Util = module.exports = {};\n\nvar POW2_24 = Math.pow(2, 24);\nvar POW2_31 = Math.pow(2, 31);\nvar POW2_32 = Math.pow(2, 32);\nvar POW10_11 = Math.pow(10, 11);\n\nInt64Util.toDecimalString = function(i64) {\n  var b = i64.buffer;\n  var o = i64.offset;\n  if ((!b[o] && !(b[o + 1] & 0xe0)) ||\n      (!~b[o] && !~(b[o + 1] & 0xe0))) {\n    // The magnitude is small enough.\n    return i64.toString();\n  } else {\n    var negative = b[o] & 0x80;\n    if (negative) {\n      // 2's complement\n      var incremented = false;\n      var buffer = new Buffer(8);\n      for (var i = 7; i >= 0; --i) {\n        buffer[i] = (~b[o + i] + (incremented ? 0 : 1)) & 0xff;\n        incremented |= b[o + i];\n      }\n      b = buffer;\n    }\n    var high2 = b[o + 1] + (b[o] << 8);\n    // Lesser 11 digits with exceeding values but is under 53 bits capacity.\n    var low = b[o + 7] + (b[o + 6] << 8) + (b[o + 5] << 16)\n        + b[o + 4] * POW2_24  // Bit shift renders 32th bit as sign, so use multiplication\n        + (b[o + 3] + (b[o + 2] << 8)) * POW2_32 + high2 * 74976710656;  // The literal is 2^48 % 10^11\n    // 12th digit and greater.\n    var high = Math.floor(low / POW10_11) + high2 * 2814;  // The literal is 2^48 / 10^11\n    // Make it exactly 11 with leading zeros.\n    low = ('00000000000' + String(low % POW10_11)).slice(-11);\n    return (negative ? '-' : '') + String(high) + low;\n  }\n};\n\nInt64Util.fromDecimalString = function(text) {\n  var negative = text.charAt(0) === '-';\n  if (text.length < (negative ? 17 : 16)) {\n    // The magnitude is smaller than 2^53.\n    return new Int64(+text);\n  } else if (text.length > (negative ? 20 : 19)) {\n    throw new RangeError('Too many digits for Int64: ' + text);\n  } else {\n    // Most significant (up to 5) digits\n    var high5 = +text.slice(negative ? 1 : 0, -15);\n    var low = +text.slice(-15) + high5 * 2764472320;  // The literal is 10^15 % 2^32\n    var high = Math.floor(low / POW2_32) + high5 * 232830;  // The literal is 10^15 / 2^&32\n    low = low % POW2_32;\n    if (high >= POW2_31 &&\n        !(negative && high == POW2_31 && low == 0)  // Allow minimum Int64\n       ) {\n      throw new RangeError('The magnitude is too large for Int64.');\n    }\n    if (negative) {\n      // 2's complement\n      high = ~high;\n      if (low === 0) {\n        high = (high + 1) & 0xffffffff;\n      } else {\n        low = ~low + 1;\n      }\n      high = 0x80000000 | high;\n    }\n    return new Int64(high, low);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/json_parse.js":"/*\n * Imported from Douglas Crockford's reference implementation with minimum modification\n * to handle Int64.\n *\n * https://github.com/douglascrockford/JSON-js/blob/c98948ae1944a28e2e8ebc3717894e580aeaaa05/json_parse.js\n *\n * Original license header:\n *\n * json_parse.js\n * 2015-05-02\n * Public Domain.\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n */\n\n\n/*jslint for */\n\n/*property\n    at, b, call, charAt, f, fromCharCode, hasOwnProperty, message, n, name,\n    prototype, push, r, t, text\n*/\n\nvar Int64 = require('node-int64');\nvar Int64Util = require('./int64_util');\n\nvar json_parse = module.exports = (function () {\n    \"use strict\";\n\n// This is a function that can parse a JSON text, producing a JavaScript\n// data structure. It is a simple, recursive descent parser. It does not use\n// eval or regular expressions, so it can be used as a model for implementing\n// a JSON parser in other languages.\n\n// We are defining the function inside of another function to avoid creating\n// global variables.\n\n    var at,     // The index of the current character\n        ch,     // The current character\n        escapee = {\n            '\"': '\"',\n            '\\\\': '\\\\',\n            '/': '/',\n            b: '\\b',\n            f: '\\f',\n            n: '\\n',\n            r: '\\r',\n            t: '\\t'\n        },\n        text,\n\n        error = function (m) {\n\n// Call error when something is wrong.\n\n            throw new SyntaxError(m);\n        },\n\n        next = function (c) {\n\n// If a c parameter is provided, verify that it matches the current character.\n\n            if (c && c !== ch) {\n                error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n            }\n\n// Get the next character. When there are no more characters,\n// return the empty string.\n\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n\n        number = function () {\n\n// Parse a number value.\n\n            var number,\n                string = '';\n\n            if (ch === '-') {\n                string = '-';\n                next('-');\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n            if (ch === '.') {\n                string += '.';\n                while (next() && ch >= '0' && ch <= '9') {\n                    string += ch;\n                }\n            }\n            if (ch === 'e' || ch === 'E') {\n                string += ch;\n                next();\n                if (ch === '-' || ch === '+') {\n                    string += ch;\n                    next();\n                }\n                while (ch >= '0' && ch <= '9') {\n                    string += ch;\n                    next();\n                }\n            }\n            number = +string;\n            if (!isFinite(number)) {\n                error(\"Bad number\");\n            } else if (number >= Int64.MAX_INT || number <= Int64.MIN_INT) {\n                // Return raw string for further process in TJSONProtocol\n                return string;\n            } else {\n                return number;\n            }\n        },\n\n        string = function () {\n\n// Parse a string value.\n\n            var hex,\n                i,\n                string = '',\n                uffff;\n\n// When parsing for string values, we must look for \" and \\ characters.\n\n            if (ch === '\"') {\n                while (next()) {\n                    if (ch === '\"') {\n                        next();\n                        return string;\n                    }\n                    if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error(\"Bad string\");\n        },\n\n        white = function () {\n\n// Skip whitespace.\n\n            while (ch && ch <= ' ') {\n                next();\n            }\n        },\n\n        word = function () {\n\n// true, false, or null.\n\n            switch (ch) {\n            case 't':\n                next('t');\n                next('r');\n                next('u');\n                next('e');\n                return true;\n            case 'f':\n                next('f');\n                next('a');\n                next('l');\n                next('s');\n                next('e');\n                return false;\n            case 'n':\n                next('n');\n                next('u');\n                next('l');\n                next('l');\n                return null;\n            }\n            error(\"Unexpected '\" + ch + \"'\");\n        },\n\n        value,  // Place holder for the value function.\n\n        array = function () {\n\n// Parse an array value.\n\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;   // empty array\n                }\n                while (ch) {\n                    array.push(value());\n                    white();\n                    if (ch === ']') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad array\");\n        },\n\n        object = function () {\n\n// Parse an object value.\n\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;   // empty object\n                }\n                while (ch) {\n                    key = string();\n                    white();\n                    next(':');\n                    if (Object.hasOwnProperty.call(object, key)) {\n                        error('Duplicate key \"' + key + '\"');\n                    }\n                    object[key] = value();\n                    white();\n                    if (ch === '}') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad object\");\n        };\n\n    value = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n        white();\n        switch (ch) {\n        case '{':\n            return object();\n        case '[':\n            return array();\n        case '\"':\n            return string();\n        case '-':\n            return number();\n        default:\n            return ch >= '0' && ch <= '9'\n                ? number()\n                : word();\n        }\n    };\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\n    return function (source) {\n        var result;\n\n        text = source;\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error(\"Syntax error\");\n        }\n\n        return result;\n    };\n}());\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/xhr_connection.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar util = require('util');\nvar EventEmitter = require(\"events\").EventEmitter;\nvar thrift = require('./thrift');\n\nvar TBufferedTransport = require('./buffered_transport');\nvar TJSONProtocol = require('./json_protocol');\nvar InputBufferUnderrunError = require('./input_buffer_underrun_error');\n\nvar createClient = require('./create_client');\n\nexports.XHRConnection = XHRConnection;\n\n/**\n * Constructor Function for the XHR Connection.\n * If you do not specify a host and port then XHRConnection will default to the\n * host and port of the page from which this javascript is served.\n * @constructor\n * @param {string} [url] - The URL to connect to.\n * @classdesc TXHRConnection objects provide Thrift end point transport\n *     semantics implemented using XHR.\n * @example\n *     var transport = new Thrift.TXHRConnection('localhost', 9099, {});\n */\nfunction XHRConnection(host, port, options) {\n  this.options = options || {};\n  this.wpos = 0;\n  this.rpos = 0;\n  this.useCORS = (options && options.useCORS);\n  this.send_buf = '';\n  this.recv_buf = '';\n  this.transport = options.transport || TBufferedTransport;\n  this.protocol = options.protocol || TJSONProtocol;\n  this.headers = options.headers || {};\n\n  host = host || window.location.host;\n  port = port || window.location.port;\n  var prefix = options.https ? 'https://' : 'http://';\n  var path = options.path || '/';\n\n  if (port === '') {\n    port = undefined;\n  }\n\n  if (!port || port === 80 || port === '80') {\n    this.url = prefix + host + path;\n  } else {\n    this.url = prefix + host + ':' + port + path;\n  }\n\n  //The sequence map is used to map seqIDs back to the\n  //  calling client in multiplexed scenarios\n  this.seqId2Service = {};\n};\n\nutil.inherits(XHRConnection, EventEmitter);\n\n/**\n* Gets the browser specific XmlHttpRequest Object.\n* @returns {object} the browser XHR interface object\n*/\nXHRConnection.prototype.getXmlHttpRequestObject = function() {\n  try { return new XMLHttpRequest(); } catch (e1) { }\n  try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e2) { }\n  try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e3) { }\n\n  throw \"Your browser doesn't support XHR.\";\n};\n\n/**\n * Sends the current XRH request if the transport was created with a URL\n * and the async parameter is false. If the transport was not created with\n * a URL, or the async parameter is True and no callback is provided, or\n * the URL is an empty string, the current send buffer is returned.\n * @param {object} async - If true the current send buffer is returned.\n * @param {object} callback - Optional async completion callback\n * @returns {undefined|string} Nothing or the current send buffer.\n * @throws {string} If XHR fails.\n */\nXHRConnection.prototype.flush = function() {\n  var self = this;\n  if (this.url === undefined || this.url === '') {\n    return this.send_buf;\n  }\n\n  var xreq = this.getXmlHttpRequestObject();\n\n  if (xreq.overrideMimeType) {\n    xreq.overrideMimeType('application/json');\n  }\n\n  xreq.onreadystatechange = function() {\n    if (this.readyState == 4 && this.status == 200) {\n      self.setRecvBuffer(this.responseText);\n    }\n  };\n\n  xreq.open('POST', this.url, true);\n\n  Object.keys(this.headers).forEach(function(headerKey) {\n    xreq.setRequestHeader(headerKey, self.headers[headerKey]);\n  });\n\n  xreq.send(this.send_buf);\n};\n\n/**\n * Sets the buffer to provide the protocol when deserializing.\n * @param {string} buf - The buffer to supply the protocol.\n */\nXHRConnection.prototype.setRecvBuffer = function(buf) {\n  this.recv_buf = buf;\n  this.recv_buf_sz = this.recv_buf.length;\n  this.wpos = this.recv_buf.length;\n  this.rpos = 0;\n\n  if (Object.prototype.toString.call(buf) == \"[object ArrayBuffer]\") {\n    var data = new Uint8Array(buf);\n  }\n  var thing = new Buffer(data || buf);\n\n  this.transport.receiver(this.__decodeCallback.bind(this))(thing);\n\n};\n\nXHRConnection.prototype.__decodeCallback = function(transport_with_data) {\n  var proto = new this.protocol(transport_with_data);\n  try {\n    while (true) {\n      var header = proto.readMessageBegin();\n      var dummy_seqid = header.rseqid * -1;\n      var client = this.client;\n      //The Multiplexed Protocol stores a hash of seqid to service names\n      //  in seqId2Service. If the SeqId is found in the hash we need to\n      //  lookup the appropriate client for this call.\n      //  The client var is a single client object when not multiplexing,\n      //  when using multiplexing it is a service name keyed hash of client\n      //  objects.\n      //NOTE: The 2 way interdependencies between protocols, transports,\n      //  connections and clients in the Node.js implementation are irregular\n      //  and make the implementation difficult to extend and maintain. We\n      //  should bring this stuff inline with typical thrift I/O stack\n      //  operation soon.\n      //  --ra\n      var service_name = this.seqId2Service[header.rseqid];\n      if (service_name) {\n        client = this.client[service_name];\n        delete this.seqId2Service[header.rseqid];\n      }\n      /*jshint -W083 */\n      client._reqs[dummy_seqid] = function(err, success) {\n        transport_with_data.commitPosition();\n        var clientCallback = client._reqs[header.rseqid];\n        delete client._reqs[header.rseqid];\n        if (clientCallback) {\n          clientCallback(err, success);\n        }\n      };\n      /*jshint +W083 */\n      if (client['recv_' + header.fname]) {\n        client['recv_' + header.fname](proto, header.mtype, dummy_seqid);\n      } else {\n        delete client._reqs[dummy_seqid];\n        this.emit(\"error\",\n          new thrift.TApplicationException(\n            thrift.TApplicationExceptionType.WRONG_METHOD_NAME,\n            \"Received a response to an unknown RPC function\"));\n      }\n    }\n  } catch (e) {\n    if (e instanceof InputBufferUnderrunError) {\n      transport_with_data.rollbackPosition();\n    } else {\n      throw e;\n    }\n  }\n};\n\n/**\n * Returns true if the transport is open, XHR always returns true.\n * @readonly\n * @returns {boolean} Always True.\n */\nXHRConnection.prototype.isOpen = function() {\n  return true;\n};\n\n/**\n * Opens the transport connection, with XHR this is a nop.\n */\nXHRConnection.prototype.open = function() {};\n\n/**\n * Closes the transport connection, with XHR this is a nop.\n */\nXHRConnection.prototype.close = function() {};\n\n/**\n * Returns the specified number of characters from the response\n * buffer.\n * @param {number} len - The number of characters to return.\n * @returns {string} Characters sent by the server.\n */\nXHRConnection.prototype.read = function(len) {\n  var avail = this.wpos - this.rpos;\n\n  if (avail === 0) {\n    return '';\n  }\n\n  var give = len;\n\n  if (avail < len) {\n    give = avail;\n  }\n\n  var ret = this.read_buf.substr(this.rpos, give);\n  this.rpos += give;\n\n  //clear buf when complete?\n  return ret;\n};\n\n/**\n * Returns the entire response buffer.\n * @returns {string} Characters sent by the server.\n */\nXHRConnection.prototype.readAll = function() {\n  return this.recv_buf;\n};\n\n/**\n * Sets the send buffer to buf.\n * @param {string} buf - The buffer to send.\n */\nXHRConnection.prototype.write = function(buf) {\n  this.send_buf = buf;\n  this.flush();\n};\n\n/**\n * Returns the send buffer.\n * @readonly\n * @returns {string} The send buffer.\n */\nXHRConnection.prototype.getSendBuffer = function() {\n  return this.send_buf;\n};\n\n/**\n * Creates a new TXHRTransport object, used by Thrift clients to connect\n *    to Thrift HTTP based servers.\n * @param {string} host - The host name or IP to connect to.\n * @param {number} port - The TCP port to connect to.\n * @param {XHRConnectOptions} options - The configuration options to use.\n * @returns {XHRConnection} The connection object.\n * @see {@link XHRConnectOptions}\n */\nexports.createXHRConnection = function(host, port, options) {\n  return new XHRConnection(host, port, options);\n};\n\nexports.createXHRClient = createClient;\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/server.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar net = require('net');\nvar tls = require('tls');\n\nvar TBufferedTransport = require('./buffered_transport');\nvar TBinaryProtocol = require('./binary_protocol');\nvar InputBufferUnderrunError = require('./input_buffer_underrun_error');\n\n/**\n * Create a Thrift server which can serve one or multiple services.\n * @param {object} processor - A normal or multiplexedProcessor (must\n *                             be preconstructed with the desired handler).\n * @param {ServerOptions} options - Optional additional server configuration.\n * @returns {object} - The Apache Thrift Multiplex Server.\n */\nexports.createMultiplexServer = function(processor, options) {\n  var transport = (options && options.transport) ? options.transport : TBufferedTransport;\n  var protocol = (options && options.protocol) ? options.protocol : TBinaryProtocol;\n\n  function serverImpl(stream) {\n    var self = this;\n    stream.on('error', function(err) {\n        self.emit('error', err);\n    });\n    stream.on('data', transport.receiver(function(transportWithData) {\n      var input = new protocol(transportWithData);\n      var output = new protocol(new transport(undefined, function(buf) {\n        try {\n            stream.write(buf);\n        } catch (err) {\n            self.emit('error', err);\n            stream.end();\n        }\n      }));\n\n      try {\n        do {\n          processor.process(input, output);\n          transportWithData.commitPosition();\n        } while (true);\n      } catch (err) {\n        if (err instanceof InputBufferUnderrunError) {\n          //The last data in the buffer was not a complete message, wait for the rest\n          transportWithData.rollbackPosition();\n        }\n        else if (err.message === \"Invalid type: undefined\") {\n          //No more data in the buffer\n          //This trap is a bit hackish\n          //The next step to improve the node behavior here is to have\n          //  the compiler generated process method throw a more explicit\n          //  error when the network buffer is empty (regardles of the\n          //  protocol/transport stack in use) and replace this heuristic.\n          //  Also transports should probably not force upper layers to\n          //  manage their buffer positions (i.e. rollbackPosition() and\n          //  commitPosition() should be eliminated in lieu of a transport\n          //  encapsulated buffer management strategy.)\n          transportWithData.rollbackPosition();\n        }\n        else {\n          //Unexpected error\n          self.emit('error', err);\n          stream.end();\n        }\n      }\n    }));\n\n    stream.on('end', function() {\n      stream.end();\n    });\n  }\n\n  if (options && options.tls) {\n    return tls.createServer(options.tls, serverImpl);\n  } else {\n    return net.createServer(serverImpl);\n  }\n};\n\n/**\n * Create a single service Apache Thrift server.\n * @param {object} processor - A service class or processor function.\n * @param {ServerOptions} options - Optional additional server configuration.\n * @returns {object} - The Apache Thrift Multiplex Server.\n */\nexports.createServer = function(processor, handler, options) {\n  if (processor.Processor) {\n    processor = processor.Processor;\n  }\n  return exports.createMultiplexServer(new processor(handler), options);\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/web_server.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar http = require('http');\nvar https = require('https');\nvar url = require(\"url\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\nvar crypto = require(\"crypto\");\n\nvar MultiplexedProcessor = require('./multiplexed_processor').MultiplexedProcessor;\n\nvar TBufferedTransport = require('./buffered_transport');\nvar TBinaryProtocol = require('./binary_protocol');\nvar InputBufferUnderrunError = require('./input_buffer_underrun_error');\n\n// WSFrame constructor and prototype\n/////////////////////////////////////////////////////////////////////\n\n/** Apache Thrift RPC Web Socket Transport\n *  Frame layout conforming to RFC 6455 circa 12/2011\n *\n * Theoretical frame size limit is 4GB*4GB, however the Node Buffer\n * limit is 1GB as of v0.10. The frame length encoding is also\n * configured for a max of 4GB presently and needs to be adjusted\n * if Node/Browsers become capabile of > 4GB frames.\n *\n *  - FIN is 1 if the message is complete\n *  - RSV1/2/3 are always 0\n *  - Opcode is 1(TEXT) for TJSONProtocol and 2(BIN) for TBinaryProtocol\n *  - Mask Present bit is 1 sending to-server and 0 sending to-client\n *  - Payload Len:\n *        + If < 126: then represented directly\n *        + If >=126: but within range of an unsigned 16 bit integer\n *             then Payload Len is 126 and the two following bytes store\n *             the length\n *        + Else: Payload Len is 127 and the following 8 bytes store the\n *             length as an unsigned 64 bit integer\n *  - Masking key is a 32 bit key only present when sending to the server\n *  - Payload follows the masking key or length\n *\n *     0                   1                   2                   3\n *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *    +-+-+-+-+-------+-+-------------+-------------------------------+\n *    |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n *    |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n *    |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n *    | |1|2|3|       |K|             |                               |\n *    +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n *    |     Extended payload length continued, if payload len == 127  |\n *    + - - - - - - - - - - - - - - - +-------------------------------+\n *    |                               |Masking-key, if MASK set to 1  |\n *    +-------------------------------+-------------------------------+\n *    | Masking-key (continued)       |          Payload Data         |\n *    +-------------------------------- - - - - - - - - - - - - - - - +\n *    :                     Payload Data continued ...                :\n *    + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n *    |                     Payload Data continued ...                |\n *    +---------------------------------------------------------------+\n */\nvar wsFrame = {\n  /** Encodes a WebSocket frame\n   *\n   * @param {Buffer} data - The raw data to encode\n   * @param {Buffer} mask - The mask to apply when sending to server, null for no mask\n   * @param {Boolean} binEncoding - True for binary encoding, false for text encoding\n   * @returns {Buffer} - The WebSocket frame, ready to send\n   */\n  encode: function(data, mask, binEncoding) {\n      var frame = new Buffer(wsFrame.frameSizeFromData(data, mask));\n      //Byte 0 - FIN & OPCODE\n      frame[0] = wsFrame.fin.FIN +\n          (binEncoding ? wsFrame.frameOpCodes.BIN : wsFrame.frameOpCodes.TEXT);\n      //Byte 1 or 1-3 or 1-9 - MASK FLAG & SIZE\n      var payloadOffset = 2;\n      if (data.length < 0x7E) {\n        frame[1] = data.length + (mask ? wsFrame.mask.TO_SERVER : wsFrame.mask.TO_CLIENT);\n      } else if (data.length < 0xFFFF) {\n        frame[1] = 0x7E + (mask ? wsFrame.mask.TO_SERVER : wsFrame.mask.TO_CLIENT);\n        frame.writeUInt16BE(data.length, 2, true);\n        payloadOffset = 4;\n      } else {\n        frame[1] = 0x7F + (mask ? wsFrame.mask.TO_SERVER : wsFrame.mask.TO_CLIENT);\n        frame.writeUInt32BE(0, 2, true);\n        frame.writeUInt32BE(data.length, 6, true);\n        payloadOffset = 10;\n      }\n      //MASK\n      if (mask) {\n        mask.copy(frame, payloadOffset, 0, 4);\n        payloadOffset += 4;\n      }\n      //Payload\n      data.copy(frame, payloadOffset);\n      if (mask) {\n        wsFrame.applyMask(frame.slice(payloadOffset), frame.slice(payloadOffset-4,payloadOffset));\n      }\n      return frame;\n  },\n\n  /**\n   * @class\n   * @name WSDecodeResult\n   * @property {Buffer} data - The decoded data for the first ATRPC message\n   * @property {Buffer} mask - The frame mask\n   * @property {Boolean} binEncoding - True if binary (TBinaryProtocol),\n   *                                   False if text (TJSONProtocol)\n   * @property {Buffer} nextFrame - Multiple ATRPC messages may be sent in a\n   *                                single WebSocket frame, this Buffer contains\n   *                                any bytes remaining to be decoded\n   * @property {Boolean} FIN - True is the message is complete\n   */\n\n   /** Decodes a WebSocket frame\n   *\n   * @param {Buffer} frame - The raw inbound frame, if this is a continuation\n   *                         frame it must have a mask property with the mask.\n   * @returns {WSDecodeResult} - The decoded payload\n   *\n   * @see {@link WSDecodeResult}\n   */\n  decode: function(frame) {\n      var result = {\n        data: null,\n        mask: null,\n        binEncoding: false,\n        nextFrame: null,\n        FIN: true\n      };\n\n      //Byte 0 - FIN & OPCODE\n      if (wsFrame.fin.FIN != (frame[0] & wsFrame.fin.FIN)) {\n        result.FIN = false;\n      }\n      result.binEncoding = (wsFrame.frameOpCodes.BIN == (frame[0] & wsFrame.frameOpCodes.BIN));\n      //Byte 1 or 1-3 or 1-9 - SIZE\n      var lenByte = (frame[1] & 0x0000007F);\n      var len = lenByte;\n      var dataOffset = 2;\n      if (lenByte == 0x7E) {\n        len = frame.readUInt16BE(2);\n        dataOffset = 4;\n      } else if (lenByte == 0x7F) {\n        len = frame.readUInt32BE(6);\n        dataOffset = 10;\n      }\n      //MASK\n      if (wsFrame.mask.TO_SERVER == (frame[1] & wsFrame.mask.TO_SERVER)) {\n        result.mask = new Buffer(4);\n        frame.copy(result.mask, 0, dataOffset, dataOffset + 4);\n        dataOffset += 4;\n      }\n      //Payload\n      result.data = new Buffer(len);\n      frame.copy(result.data, 0, dataOffset, dataOffset+len);\n      if (result.mask) {\n        wsFrame.applyMask(result.data, result.mask);\n      }\n      //Next Frame\n      if (frame.length > dataOffset+len) {\n        result.nextFrame = new Buffer(frame.length - (dataOffset+len));\n        frame.copy(result.nextFrame, 0, dataOffset+len, frame.length);\n      }\n      //Don't forward control frames\n      if (frame[0] & wsFrame.frameOpCodes.FINCTRL) {\n        result.data = null;\n      }\n\n      return result;\n  },\n\n  /** Masks/Unmasks data\n   *\n   * @param {Buffer} data - data to mask/unmask in place\n   * @param {Buffer} mask - the mask\n   */\n  applyMask: function(data, mask){\n    //TODO: look into xoring words at a time\n    var dataLen = data.length;\n    var maskLen = mask.length;\n    for (var i = 0; i < dataLen; i++) {\n      data[i] = data[i] ^ mask[i%maskLen];\n    }\n  },\n\n  /** Computes frame size on the wire from data to be sent\n   *\n   * @param {Buffer} data - data.length is the assumed payload size\n   * @param {Boolean} mask - true if a mask will be sent (TO_SERVER)\n   */\n  frameSizeFromData: function(data, mask) {\n    var headerSize = 10;\n    if (data.length < 0x7E) {\n      headerSize = 2;\n    } else if (data.length < 0xFFFF) {\n      headerSize = 4;\n    }\n    return headerSize + data.length + (mask ? 4 : 0);\n  },\n\n  frameOpCodes: {\n    CONT:     0x00,\n    TEXT:     0x01,\n    BIN:      0x02,\n    CTRL:     0x80\n  },\n\n  mask: {\n    TO_SERVER: 0x80,\n    TO_CLIENT: 0x00\n  },\n\n  fin: {\n    CONT: 0x00,\n    FIN: 0x80\n  }\n};\n\n\n// createWebServer constructor and options\n/////////////////////////////////////////////////////////////////////\n\n/**\n * @class\n * @name ServerOptions\n * @property {array} cors - Array of CORS origin strings to permit requests from.\n * @property {string} files - Path to serve static files from, if absent or \"\"\n *                               static file service is disabled.\n * @property {object} headers - An object hash mapping header strings to header value\n *                              strings, these headers are transmitted in response to\n *                              static file GET operations.\n * @property {object} services - An object hash mapping service URI strings\n *                               to ServiceOptions objects\n * @property {object} tls - Node.js TLS options (see: nodejs.org/api/tls.html),\n *                          if not present or null regular http is used,\n *                          at least a key and a cert must be defined to use SSL/TLS\n * @see {@link ServiceOptions}\n */\n\n/**\n * @class\n * @name ServiceOptions\n * @property {object} transport - The layered transport to use (defaults\n *                                to TBufferedTransport).\n * @property {object} protocol - The serialization Protocol to use (defaults to\n *                               TBinaryProtocol).\n * @property {object} processor - The Thrift Service class/processor generated\n *                                by the IDL Compiler for the service (the \"cls\"\n *                                key can also be used for this attribute).\n * @property {object} handler - The handler methods for the Thrift Service.\n */\n\n/**\n * Create a Thrift server which can serve static files and/or one or\n * more Thrift Services.\n * @param {ServerOptions} options - The server configuration.\n * @returns {object} - The Apache Thrift Web Server.\n */\nexports.createWebServer = function(options) {\n  var baseDir = options.files;\n  var contentTypesByExtension = {\n    '.txt': 'text/plain',\n    '.html': 'text/html',\n    '.css': 'text/css',\n    '.xml': 'application/xml',\n    '.json': 'application/json',\n    '.js': 'application/javascript',\n    '.jpg': 'image/jpeg',\n    '.jpeg': 'image/jpeg',\n    '.gif': 'image/gif',\n    '.png': 'image/png',\n    '.svg': 'image/svg+xml'\n  };\n\n  //Setup all of the services\n  var services = options.services;\n  for (var uri in services) {\n    var svcObj = services[uri];\n\n    //Setup the processor\n    if (svcObj.processor instanceof MultiplexedProcessor) {\n      //Multiplex processors have pre embedded processor/handler pairs, save as is\n      svcObj.processor = svcObj.processor;\n    } else {\n      //For historical reasons Node.js supports processors passed in directly or via the\n      //  IDL Compiler generated class housing the processor. Also, the options property\n      //  for a Processor has been called both cls and processor at different times. We\n      //  support any of the four possibilities here.\n      var processor = (svcObj.processor) ? (svcObj.processor.Processor || svcObj.processor) :\n                                           (svcObj.cls.Processor || svcObj.cls);\n      //Processors can be supplied as constructed objects with handlers already embedded,\n      //  if a handler is provided we construct a new processor, if not we use the processor\n      //  object directly\n      if (svcObj.handler) {\n        svcObj.processor = new processor(svcObj.handler);\n      } else {\n        svcObj.processor = processor;\n      }\n    }\n    svcObj.transport = svcObj.transport ? svcObj.transport : TBufferedTransport;\n    svcObj.protocol = svcObj.protocol ? svcObj.protocol : TBinaryProtocol;\n  }\n\n  //Verify CORS requirements\n  function VerifyCORSAndSetHeaders(request, response) {\n    if (request.headers.origin && options.cors) {\n      if (options.cors[\"*\"] || options.cors[request.headers.origin]) {\n        //Allow, origin allowed\n        response.setHeader(\"access-control-allow-origin\", request.headers.origin);\n        response.setHeader(\"access-control-allow-methods\", \"GET, POST, OPTIONS\");\n        response.setHeader(\"access-control-allow-headers\", \"content-type, accept\");\n        response.setHeader(\"access-control-max-age\", \"60\");\n        return true;\n      } else {\n        //Disallow, origin denied\n        return false;\n      }\n    }\n    //Allow, CORS is not in use\n    return true;\n  }\n\n\n  //Handle OPTIONS method (CORS)\n  ///////////////////////////////////////////////////\n  function processOptions(request, response) {\n    if (VerifyCORSAndSetHeaders(request, response)) {\n      response.writeHead(\"204\", \"No Content\", {\"content-length\": 0});\n    } else {\n      response.writeHead(\"403\", \"Origin \" + request.headers.origin + \" not allowed\", {});\n    }\n    response.end();\n  }\n\n\n  //Handle POST methods (TXHRTransport)\n  ///////////////////////////////////////////////////\n  function processPost(request, response) {\n    //Lookup service\n    var uri = url.parse(request.url).pathname;\n    var svc = services[uri];\n    if (!svc) {\n      response.writeHead(\"403\", \"No Apache Thrift Service at \" + uri, {});\n      response.end();\n      return;\n    }\n\n    //Verify CORS requirements\n    if (!VerifyCORSAndSetHeaders(request, response)) {\n      response.writeHead(\"403\", \"Origin \" + request.headers.origin + \" not allowed\", {});\n      response.end();\n      return;\n    }\n\n    //Process XHR payload\n    request.on('data', svc.transport.receiver(function(transportWithData) {\n      var input = new svc.protocol(transportWithData);\n      var output = new svc.protocol(new svc.transport(undefined, function(buf) {\n        try {\n          response.writeHead(200);\n          response.end(buf);\n        } catch (err) {\n          response.writeHead(500);\n          response.end();\n        }\n      }));\n\n      try {\n        svc.processor.process(input, output);\n        transportWithData.commitPosition();\n      } catch (err) {\n        if (err instanceof InputBufferUnderrunError) {\n          transportWithData.rollbackPosition();\n        } else {\n          response.writeHead(500);\n          response.end();\n        }\n      }\n    }));\n  }\n\n\n  //Handle GET methods (Static Page Server)\n  ///////////////////////////////////////////////////\n  function processGet(request, response) {\n    //Undefined or empty base directory means do not serve static files\n    if (!baseDir || \"\" === baseDir) {\n      response.writeHead(404);\n      response.end();\n      return;\n    }\n\n    //Verify CORS requirements\n    if (!VerifyCORSAndSetHeaders(request, response)) {\n      response.writeHead(\"403\", \"Origin \" + request.headers.origin + \" not allowed\", {});\n      response.end();\n      return;\n    }\n\n    //Locate the file requested and send it\n    var uri = url.parse(request.url).pathname;\n    var filename = path.join(baseDir, uri);\n    fs.exists(filename, function(exists) {\n      if(!exists) {\n        response.writeHead(404);\n        response.end();\n        return;\n      }\n\n      if (fs.statSync(filename).isDirectory()) {\n        filename += '/index.html';\n      }\n\n      fs.readFile(filename, \"binary\", function(err, file) {\n        if (err) {\n          response.writeHead(500);\n          response.end(err + \"\\n\");\n          return;\n        }\n        var headers = {};\n        var contentType = contentTypesByExtension[path.extname(filename)];\n        if (contentType) {\n          headers[\"Content-Type\"] = contentType;\n        }\n        for (var k in options.headers) {\n          headers[k] = options.headers[k];\n        }\n        response.writeHead(200, headers);\n        response.write(file, \"binary\");\n        response.end();\n      });\n    });\n  }\n\n\n  //Handle WebSocket calls (TWebSocketTransport)\n  ///////////////////////////////////////////////////\n  function processWS(data, socket, svc, binEncoding) {\n    svc.transport.receiver(function(transportWithData) {\n      var input = new svc.protocol(transportWithData);\n      var output = new svc.protocol(new svc.transport(undefined, function(buf) {\n        try {\n          var frame = wsFrame.encode(buf, null, binEncoding);\n          socket.write(frame);\n        } catch (err) {\n          //TODO: Add better error processing\n        }\n      }));\n\n      try {\n        svc.processor.process(input, output);\n        transportWithData.commitPosition();\n      }\n      catch (err) {\n        if (err instanceof InputBufferUnderrunError) {\n          transportWithData.rollbackPosition();\n        }\n        else {\n          //TODO: Add better error processing\n        }\n      }\n    })(data);\n  }\n\n  //Create the server (HTTP or HTTPS)\n  var server = null;\n  if (options.tls) {\n    server = https.createServer(options.tls);\n  } else {\n    server = http.createServer();\n  }\n\n  //Wire up listeners for upgrade(to WebSocket) & request methods for:\n  //   - GET static files,\n  //   - POST XHR Thrift services\n  //   - OPTIONS CORS requests\n  server.on('request', function(request, response) {\n    if (request.method === 'POST') {\n      processPost(request, response);\n    } else if (request.method === 'GET') {\n      processGet(request, response);\n    } else if (request.method === 'OPTIONS') {\n      processOptions(request, response);\n    } else {\n      response.writeHead(500);\n      response.end();\n    }\n  }).on('upgrade', function(request, socket, head) {\n    //Lookup service\n    var svc;\n    try {\n      svc = services[Object.keys(services)[0]];\n    } catch(e) {\n      socket.write(\"HTTP/1.1 403 No Apache Thrift Service available\\r\\n\\r\\n\");\n      return;\n    }\n    //Perform upgrade\n    var hash = crypto.createHash(\"sha1\");\n    hash.update(request.headers['sec-websocket-key'] + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    socket.write(\"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                   \"Upgrade: websocket\\r\\n\" +\n                   \"Connection: Upgrade\\r\\n\" +\n                   \"Sec-WebSocket-Accept: \" + hash.digest(\"base64\") + \"\\r\\n\" +\n                   \"Sec-WebSocket-Origin: \" + request.headers.origin + \"\\r\\n\" +\n                   \"Sec-WebSocket-Location: ws://\" + request.headers.host + request.url + \"\\r\\n\" +\n                   \"\\r\\n\");\n    //Handle WebSocket traffic\n    var data = null;\n    socket.on('data', function(frame) {\n      try {\n        while (frame) {\n          var result = wsFrame.decode(frame);\n          //Prepend any existing decoded data\n          if (data) {\n            if (result.data) {\n              var newData = new Buffer(data.length + result.data.length);\n              data.copy(newData);\n              result.data.copy(newData, data.length);\n              result.data = newData;\n            } else {\n              result.data = data;\n            }\n            data = null;\n          }\n          //If this completes a message process it\n          if (result.FIN) {\n            processWS(result.data, socket, svc, result.binEncoding);\n          } else {\n            data = result.data;\n          }\n          //Prepare next frame for decoding (if any)\n          frame = result.nextFrame;\n        }\n      } catch(e) {\n        console.log(\"TWebSocketTransport Exception: \" + e);\n        socket.destroy();\n      }\n    });\n  });\n\n  //Return the server\n  return server;\n};\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/multiplexed_processor.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar Thrift = require('./thrift');\n\nexports.MultiplexedProcessor = MultiplexedProcessor;\n\nfunction MultiplexedProcessor(stream, options) {\n  this.services = {};\n};\n\nMultiplexedProcessor.prototype.registerProcessor = function(name, handler) {\n  this.services[name] = handler;\n};\n\nMultiplexedProcessor.prototype.process = function(inp, out) {\n  var begin = inp.readMessageBegin();\n\n  if (begin.mtype != Thrift.MessageType.CALL && begin.mtype != Thrift.MessageType.ONEWAY) {\n    throw new Thrift.TException('TMultiplexedProcessor: Unexpected message type');\n  }\n\n  var p = begin.fname.split(':');\n  var sname = p[0];\n  var fname = p[1];\n\n  if (! (sname in this.services)) {\n    throw new Thrift.TException('TMultiplexedProcessor: Unknown service: ' + sname);\n  }\n\n  //construct a proxy object which stubs the readMessageBegin\n  //for the service\n  var inpProxy = {};\n\n  for (var attr in inp) {\n    inpProxy[attr] = inp[attr];\n  }\n\n  inpProxy.readMessageBegin = function() {\n    return {\n      fname: fname,\n      mtype: begin.mtype,\n      rseqid: begin.rseqid\n    };\n  };\n\n  this.services[sname].process(inpProxy, out);\n};\n","/home/travis/build/npmtest/node-npmtest-thrift/node_modules/thrift/lib/nodejs/lib/thrift/multiplexed_protocol.js":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar util = require('util');\nvar Thrift = require('./thrift');\n\nexports.Multiplexer = Multiplexer;\n\nfunction Wrapper(serviceName, protocol, connection) {\n\n  function MultiplexProtocol(trans, strictRead, strictWrite) {\n    protocol.call(this, trans, strictRead, strictWrite);\n  };\n\n  util.inherits(MultiplexProtocol, protocol);\n\n  MultiplexProtocol.prototype.writeMessageBegin = function(name, type, seqid) {\n    if (type == Thrift.MessageType.CALL || type == Thrift.MessageType.ONEWAY) {\n      connection.seqId2Service[seqid] = serviceName;\n      MultiplexProtocol.super_.prototype.writeMessageBegin.call(this,\n                                                                serviceName + \":\" + name,\n                                                                type,\n                                                                seqid);\n    } else {\n      MultiplexProtocol.super_.prototype.writeMessageBegin.call(this, name, type, seqid);\n    }\n  };\n\n  return MultiplexProtocol;\n};\n\nfunction Multiplexer() {\n  this.seqid = 0;\n};\n\nMultiplexer.prototype.createClient = function(serviceName, ServiceClient, connection) {\n  if (ServiceClient.Client) {\n    ServiceClient = ServiceClient.Client;\n  }\n  var self = this;\n  ServiceClient.prototype.new_seqid = function() {\n    self.seqid += 1;\n    return self.seqid;\n  };\n  var writeCb = function(buf, seqid) {\n    connection.write(buf,seqid);\n  };\n  var transport = new connection.transport(undefined, writeCb);\n  var protocolWrapper = new Wrapper(serviceName, connection.protocol, connection);\n  var client = new ServiceClient(transport, protocolWrapper);\n\n  if (typeof connection.client !== 'object') {\n    connection.client = {};\n  }\n  connection.client[serviceName] = client;\n\n  return client;\n};\n"}